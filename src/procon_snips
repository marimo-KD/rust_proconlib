snippet Mo
mod mo {
    pub trait State {
        type Answer: std::clone::Clone + std::default::Default;
        fn add_left(&mut self, idx: usize);
        fn add_right(&mut self, idx: usize);
        fn erase_left(&mut self, idx: usize);
        fn erase_right(&mut self, idx: usize);
        fn answer(&mut self, idx: usize) -> Self::Answer;
    }
    pub struct Mo<T: State> {
        state: T,
        n: usize,
        query: Vec<(usize, usize)>,
    }
    impl<T: State> Mo<T> {
        fn new(state: T, n: usize) -> Self {
            Self {
                state,
                n,
                query: vec![(0, 0); 0],
            }
        }
        fn add(&mut self, l: usize, r: usize) {
            self.query.push((l, r));
        }
        fn run(&mut self) -> Vec<T::Answer> {
            let q = self.query.len();
            let w = (self.n as f64).sqrt() as usize;
            let mut ret = vec![T::Answer::default(); q];
            let mut order: Vec<_> = (0..q).collect();
            order.sort_by(|&i, &j| {
                if self.query[i].0 / w != self.query[j].0 / w {
                    self.query[i].0.cmp(&self.query[j].0)
                } else {
                    self.query[i].1.cmp(&self.query[j].1)
                }
            });
            let (mut lb, mut rb) = (0, 0);
            for i in order {
                let (li, ri) = self.query[i];
                while lb > li {
                    lb -= 1;
                    self.state.add_left(lb);
                }
                while rb < ri {
                    self.state.add_right(rb);
                    rb += 1;
                }
                while lb < li {
                    self.state.erase_left(lb);
                    lb += 1;
                }
                while rb > ri {
                    rb -= 1;
                    self.state.erase_right(rb);
                }
                ret[i] = self.state.answer(i);
            }
            ret
        }
    }
}
endsnippet

snippet combination
mod modint {
    use std::ops::*;
    pub trait Mod: Copy {
        fn m() -> u64;
    }
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub struct Modint<M> {
        x: u64,
        phantom: std::marker::PhantomData<M>,
    }
    impl<M: Mod> Modint<M> {
        pub fn new(x: i64) -> Self {
            Modint::new_internal(((x % (M::m() as i64) + M::m() as i64) % M::m() as i64) as u64)
        }
        fn new_internal(x: u64) -> Self {
            Modint {
                x,
                phantom: std::marker::PhantomData,
            }
        }
        pub fn pow(self, mut e: u64) -> Self {
            let mut res = Modint::new_internal(1);
            let mut acc = self;
            while e > 0 {
                if e % 2 != 0 {
                    res *= acc;
                }
                acc *= acc;
                e /= 2;
            }
            res
        }
        pub fn inv(self) -> Self {
            self.pow(M::m() - 2)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Add<T> for Modint<M> {
        type Output = Self;
        fn add(self, other: T) -> Self {
            let mut sum = self.x + other.into().x;
            if sum >= M::m() {
                sum -= M::m();
            }
            Modint::new_internal(sum)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Sub<T> for Modint<M> {
        type Output = Self;
        fn sub(self, other: T) -> Self {
            let mut diff = self.x as i64 - other.into().x as i64;
            if diff < 0 {
                diff += M::m() as i64;
            }
            Modint::new_internal(diff as u64)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Mul<T> for Modint<M> {
        type Output = Self;
        fn mul(self, other: T) -> Self {
            Modint::new((self.x * other.into().x) as i64)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> AddAssign<T> for Modint<M> {
        fn add_assign(&mut self, other: T) {
            *self = *self + other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> SubAssign<T> for Modint<M> {
        fn sub_assign(&mut self, other: T) {
            *self = *self - other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> MulAssign<T> for Modint<M> {
        fn mul_assign(&mut self, other: T) {
            *self = *self * other;
        }
    }
    impl<M> std::fmt::Display for Modint<M> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            self.x.fmt(f)
        }
    }
    impl<M: Mod> From<i64> for Modint<M> {
        fn from(x: i64) -> Self {
            Self::new(x)
        }
    }
    impl<M: Mod> From<i32> for Modint<M> {
        fn from(x: i32) -> Self {
            Self::new(x as i64)
        }
    }
    impl<M: Mod> From<usize> for Modint<M> {
        fn from(x: usize) -> Self {
            Self::new(x as i64)
        }
    }
}
mod combination {
    use super::modint;
    pub struct CombinationCalculator<M: modint::Mod> {
        fac: Vec<modint::Modint<M>>,
        facinv: Vec<modint::Modint<M>>,
    }
    impl<M: modint::Mod> CombinationCalculator<M> {
        pub fn new(max: usize) -> Self {
            let max = max + 1;
            let mut fac = vec![modint::Modint::new(1); max];
            let mut facinv = vec![modint::Modint::new(1); max];
            for i in 2..max {
                fac[i] = fac[i - 1] * i;
            }
            facinv[max - 1] = fac[max - 1].inv();
            for i in (0..max - 1).rev() {
                facinv[i] = facinv[i + 1] * (i + 1);
            }
            Self { fac, facinv }
        }
        pub fn calc(&self, n: usize, k: usize) -> modint::Modint<M> {
            if n < k {
                return modint::Modint::new(0);
            }
            self.fac[n] * self.facinv[k] * self.facinv[n - k]
        }
    }
}
endsnippet

snippet fenwick_tree
struct FenwickTree<T> {
    data: Vec<T>,
}
impl<
        T: std::ops::Add<Output = T>
            + std::ops::Sub<Output = T>
            + std::default::Default
            + std::marker::Copy,
    > FenwickTree<T>
{
    fn new(n: usize) -> Self {
        let mut ret = Self {
            data: vec![std::default::Default::default(); n + 1],
        };
        ret.build();
        ret
    }
    fn new_with_init(mut data: Vec<T>) -> Self {
        let mut ret = Self { data };
        ret.build();
        ret
    }
    fn build(&mut self) {
        for i in 1..self.data.len() as i32 {
            let j = (i + (i & -i)) as usize;
            if j < self.data.len() {
                self.data[j] = self.data[j] + self.data[i as usize];
            }
        }
    }
    fn add(&mut self, mut k: usize, x: T) {
        k += 1;
        while k < self.data.len() {
            self.data[k] = self.data[k] + x;
            k += {
                let k = k as i32;
                (k & -k) as usize
            }
        }
    }
    fn query0(&mut self, mut k: usize) -> T {
        let mut ret: T = std::default::Default::default();
        while k > 0 {
            ret = ret + self.data[k];
            k -= {
                let k = k as i32;
                (k & -k) as usize
            };
        }
        ret
    }
    fn query(&mut self, l: usize, r: usize) -> T {
        self.query0(r) - self.query0(l)
    }
}
endsnippet

snippet geometry
mod geometry {
    use std::ops::*;
    #[derive(Debug, Copy, Clone, PartialOrd, PartialEq, Ord, Eq, Default)]
    struct Point<T> {
        x: T,
        y: T,
    }
    impl<T: Add<Output = T>> Add for Point<T> {
        type Output = Self;
        fn add(self, other: Self) -> Self {
            Self {
                x: self.x + other.x,
                y: self.y + other.y,
            }
        }
    }
    impl<T: Sub<Output = T>> Sub for Point<T> {
        type Output = Self;
        fn sub(self, other: Self) -> Self {
            Self {
                x: self.x - other.x,
                y: self.y - other.y,
            }
        }
    }
    impl<T: Mul<Output = T> + Copy> Mul<T> for Point<T> {
        type Output = Self;
        fn mul(self, other: T) -> Self {
            Self {
                x: self.x * other,
                y: self.y * other,
            }
        }
    }
    impl<T: Div<Output = T> + Copy> Div<T> for Point<T> {
        type Output = Self;
        fn div(self, other: T) -> Self {
            Self {
                x: self.x / other,
                y: self.y / other,
            }
        }
    }
    impl<T> From<(T, T)> for Point<T> {
        fn from(a: (T, T)) -> Self {
            Self { x: a.0, y: a.1 }
        }
    }
    trait Abs {
        fn abs(self) -> Self;
    }
    impl<T: Default> Point<T> {
        fn new() -> Self {
            Default::default()
        }
    }
    impl<T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Into<f64> + Abs + Ord + Copy>
        Point<T>
    {
        #[inline]
        fn dot(self, other: Self) -> T {
            self.x * other.x + self.y * other.y
        }
        #[inline]
        fn cross(self, other: Self) -> T {
            self.x * other.y - self.y * other.x
        }
        #[inline]
        fn norm(self) -> f64 {
            (self.x * self.x + self.y * self.y).into().sqrt()
        }
        #[inline]
        fn l1norm(self) -> T {
            self.x.abs() + self.y.abs()
        }
        #[inline]
        fn linfnorm(self) -> T {
            self.x.abs().max(self.y.abs())
        }
    }
}
endsnippet

snippet get_macro
macro_rules ! get {($ ($ t : tt ) ,*; $ n : expr ) => {{let stdin = std :: io :: stdin () ; let ret = std :: io :: BufRead :: lines (stdin . lock () ) . take ($ n ) . map (| line | {let line = line . unwrap () ; let mut it = line . split_whitespace () ; _get ! (it ; $ ($ t ) ,* ) } ) . collect ::< Vec < _ >> () ; ret } } ; ($ ($ t : tt ) ,* ) => {{let mut line = String :: new () ; std :: io :: stdin () . read_line (& mut line ) . unwrap () ; let mut it = line . split_whitespace () ; _get ! (it ; $ ($ t ) ,* ) } } ; }
macro_rules ! _get {($ it : ident ; [char ] ) => {_get ! ($ it ; String ) . chars () . collect ::< Vec < _ >> () } ; ($ it : ident ; [u8 ] ) => {_get ! ($ it ; String ) . bytes () . collect ::< Vec < _ >> () } ; ($ it : ident ; usize1 ) => {$ it . next () . unwrap () . parse ::< usize > () . unwrap_or_else (| e | panic ! ("{}" , e ) ) - 1 } ; ($ it : ident ; [usize1 ] ) => {$ it . map (| s | s . parse ::< usize > () . unwrap_or_else (| e | panic ! ("{}" , e ) ) - 1 ) . collect ::< Vec < _ >> () } ; ($ it : ident ; [$ t : ty ] ) => {$ it . map (| s | s . parse ::<$ t > () . unwrap_or_else (| e | panic ! ("{}" , e ) ) ) . collect ::< Vec < _ >> () } ; ($ it : ident ; $ t : ty ) => {$ it . next () . unwrap () . parse ::<$ t > () . unwrap_or_else (| e | panic ! ("{}" , e ) ) } ; ($ it : ident ; $ ($ t : tt ) ,+ ) => {($ (_get ! ($ it ; $ t ) ) ,* ) } ; }
endsnippet

snippet lazy_segment_tree
mod lazy_segment_tree {
    pub trait Element<T: Effecter>: Clone {
        fn id() -> Self;
        fn op(&self, x: Self) -> Self;
        fn affect(&self, x: T) -> Self;
    }
    pub trait Effecter: Clone + Eq {
        fn id() -> Self;
        fn op(&self, x: Self) -> Self;
    }
    pub struct LazySegmentTree<T: Element<S>, S: Effecter> {
        data: Vec<T>,
        lazy: Vec<S>,
        len: usize,
        height: usize,
    }
    impl<T: Element<S>, S: Effecter> LazySegmentTree<T, S> {
        #[inline]
        fn get_proper_size(len: usize) -> (usize, usize) {
            let ret = len.next_power_of_two();
            (ret, ret.trailing_zeros() as usize)
        }
        #[inline]
        fn propagate(&mut self, k: usize) {
            if self.lazy[k] != S::id() {
                self.lazy[2 * k] = self.lazy[2 * k].op(self.lazy[k].clone());
                self.lazy[2 * k + 1] = self.lazy[2 * k + 1].op(self.lazy[k].clone());
                self.data[k] = self.apply(k);
                self.lazy[k] = S::id();
            }
        }
        #[inline]
        fn apply(&mut self, k: usize) -> T {
            if self.lazy[k] != S::id() {
                self.data[k].clone()
            } else {
                self.data[k].affect(self.lazy[k].clone())
            }
        }
        #[inline]
        fn recalc(&mut self, mut k: usize) {
            k >>= 1;
            while k > 0 {
                self.data[k] = self.apply(2 * k).op(self.apply(2 * k + 1));
                k >>= 1;
            }
        }
        #[inline]
        fn thrust(&mut self, k: usize) {
            (1..=self.height).rev().for_each(|i| self.propagate(k >> i));
        }
        pub fn new(len: usize) -> Self {
            let (len, height) = Self::get_proper_size(len);
            Self {
                data: vec![T::id(); 2 * len],
                lazy: vec![S::id(); 2 * len],
                len,
                height,
            }
        }
        pub fn update(&mut self, l: usize, r: usize, x: &S) {
            if l >= r {
                return;
            }
            let (mut l, mut r) = (l + self.len, r + self.len);
            self.thrust(l);
            self.thrust(r - 1);
            while l < r {
                if l % 2 == 1 {
                    self.lazy[l] = x.op(self.lazy[l].clone());
                    l += 1;
                }
                if r % 2 == 1 {
                    r -= 1;
                    self.lazy[r] = self.lazy[r].op(x.clone());
                }
            }
        }
        pub fn query(&mut self, l: usize, r: usize) -> T {
            if l >= r {
                return T::id();
            }
            let (mut l, mut r) = (l + self.len, r + self.len);
            self.thrust(l);
            self.thrust(r);
            let (mut L, mut R) = (T::id(), T::id());
            while l < r {
                if l % 2 == 1 {
                    L = L.op(self.apply(l));
                    l += 1;
                }
                if r % 2 == 1 {
                    r -= 1;
                    R = R.op(self.apply(r));
                }
            }
            L.op(R)
        }
    }
}
mod monoids {
    use super::lazy_segment_tree::*;
    #[derive(Clone, Eq, PartialEq)]
    struct SumMonoid(i64);
    impl Element<SetMonoid> for SumMonoid {
        fn id() -> Self {
            Self(0)
        }
        fn op(&self, other: Self) -> Self {
            Self(self.0 + other.0)
        }
        fn affect(&self, x: SetMonoid) -> Self {
            Self(x.0)
        }
    }
    #[derive(Clone, Eq, PartialEq)]
    struct SetMonoid(i64);
    impl Effecter for SetMonoid {
        fn id() -> Self {
            Self(-1)
        }
        fn op(&self, other: Self) -> Self {
            Self(other.0)
        }
    }
}
endsnippet

snippet scanner
pub mod scanner {
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use std::io;
    use std::io::BufRead;
    use std::str::FromStr;
    struct Tokenizer<T: BufRead> {
        source: T,
        tokens: VecDeque<String>,
        buf: String,
    }
    impl<T: BufRead> Tokenizer<T> {
        fn new(source: T) -> Self {
            Self {
                source,
                tokens: VecDeque::new(),
                buf: String::new(),
            }
        }
    }
    impl<T: BufRead> Iterator for Tokenizer<T> {
        type Item = String;
        fn next(&mut self) -> Option<Self::Item> {
            while self.tokens.is_empty() {
                self.buf.clear();
                self.source.read_line(&mut self.buf).unwrap();
                for i in self.buf.split_whitespace() {
                    self.tokens.push_back(String::from(i));
                }
            }
            Some(self.tokens.pop_front().unwrap())
        }
    }
    pub struct Scanner<T: BufRead> {
        tokenizer: Tokenizer<T>,
    }
    impl<T: BufRead> Scanner<T> {
        pub fn new(source: T) -> Self {
            Self {
                tokenizer: Tokenizer::new(source),
            }
        }
        pub fn scan<U: FromStr>(&mut self) -> U {
            self.tokenizer.next().unwrap().parse::<U>().ok().unwrap()
        }
    }
    pub fn build_scanner() -> Scanner<io::StdinLock<'static>> {
        let stdin = Box::leak(Box::new(io::stdin()));
        Scanner {
            tokenizer: Tokenizer::new(stdin.lock()),
        }
    }
}
macro_rules ! scan {($ scanner : ident ; [char ] ) => {$ scanner . scan ::< String > () . chars () . collect ::< Vec < _ >> () } ; ($ scanner : ident ; [u8 ] ) => {$ scanner . scan ::< String > () . bytes . collect ::< Vec < _ >> () } ; ($ scanner : ident ; [$ ($ t : tt ) ,+; $ n : expr ] ) => {(0 ..$ n ) . map (| _ | ($ (scan ! ($ scanner ;$ t ) ) ,* ) ) . collect ::< Vec < _ >> () } ; ($ scanner : ident ; $ t : ty ) => {$ scanner . scan ::<$ t > () } ; ($ scanner : ident ; $ ($ t : tt ) ,+ ) => {($ (scan ! ($ scanner ; $ t ) ) ,* ) } ; }
endsnippet

snippet segment_tree
mod segment_tree {
    pub trait Monoid: Clone {
        fn id() -> Self;
        fn op(&self, x: &Self) -> Self;
    }
    pub struct SegmentTree<T: Monoid> {
        data: Vec<T>,
        len: usize,
    }
    impl<T: Monoid> SegmentTree<T> {
        fn get_proper_size(len: usize) -> usize {
            len.next_power_of_two()
        }
        pub fn new(len: usize) -> Self {
            let len = Self::get_proper_size(len);
            Self {
                data: vec![T::id(); 2 * len],
                len,
            }
        }
        pub fn new_with_init(&mut self, initializer: &Vec<T>) {
            let len = Self::get_proper_size(initializer.len());
            let mut data = vec![T::id(); 2 * len];
            for (idx, val) in initializer.iter().enumerate() {
                data[idx + len] = val.clone();
            }
            for i in (1..len).rev() {
                data[i] = data[2 * i].op(&data[2 * i + 1]);
            }
            self.len = len;
            self.data = data;
        }
        pub fn set(&mut self, mut idx: usize, x: &T) {
            idx += self.len;
            self.data[idx] = x.clone();
            idx /= 2;
            while idx > 0 {
                self.data[idx] = self.data[2 * idx].op(&self.data[2 * idx + 1]);
                idx /= 2;
            }
        }
        pub fn query(&self, a: usize, b: usize) -> T {
            let (mut vl, mut vr) = (T::id(), T::id());
            let (mut l, mut r) = (a + self.len, b + self.len);
            while l < r {
                if l % 2 == 1 {
                    vl = vl.op(&self.data[l]);
                    l += 1;
                }
                if r % 2 == 1 {
                    r -= 1;
                    vr = self.data[r].op(&vr);
                }
                l /= 2;
                r /= 2;
            }
            vl.op(&vr)
        }
    }
    impl<T: Monoid> std::ops::Index<usize> for SegmentTree<T> {
        type Output = T;
        fn index(&self, idx: usize) -> &T {
            &self.data[idx + self.len]
        }
    }
}
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct AddMonoid(i32);
impl segment_tree::Monoid for AddMonoid {
    fn id() -> Self {
        Self(0)
    }
    fn op(&self, x: &Self) -> Self {
        Self(self.0 + x.0)
    }
}
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct MaxMonoid(i32);
impl segment_tree::Monoid for MaxMonoid {
    fn id() -> Self {
        Self(0)
    }
    fn op(&self, x: &Self) -> Self {
        Self(self.0.max(x.0))
    }
}
endsnippet

snippet static_modint
mod modint {
    use std::ops::*;
    pub trait Mod: Copy {
        const M: u64;
        const S: u64;
        const X: u64;
        fn div(x: u64) -> u64;
        fn modulo(x: u64) -> u64;
    }
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub struct Modint<M> {
        x: u64,
        phantom: std::marker::PhantomData<M>,
    }
    impl<M: Mod> Modint<M> {
        pub fn new(x: u64) -> Self {
            Modint::new_internal(M::modulo(x))
        }
        fn new_internal(x: u64) -> Self {
            Self {
                x,
                phantom: std::marker::PhantomData,
            }
        }
        pub fn value(self) -> u64 {
            self.x
        }
        pub fn pow(self, mut e: u64) -> Self {
            let mut res = Modint::new_internal(1);
            let mut acc = self;
            while e > 0 {
                if e % 2 != 0 {
                    res *= acc;
                }
                acc *= acc;
                e /= 2;
            }
            res
        }
        pub fn inv(self) -> Self {
            self.pow(M::M - 2)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Add<T> for Modint<M> {
        type Output = Self;
        fn add(self, other: T) -> Self {
            let mut sum = self.x + other.into().x;
            if sum >= M::M {
                sum -= M::M;
            }
            Modint::new_internal(sum)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Sub<T> for Modint<M> {
        type Output = Self;
        fn sub(self, other: T) -> Self {
            let mut diff = self.x as i64 - other.into().x as i64;
            if diff < 0 {
                diff += M::M as i64;
            }
            Modint::new_internal(diff as u64)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Mul<T> for Modint<M> {
        type Output = Self;
        fn mul(self, other: T) -> Self {
            Self::new(self.x.wrapping_mul(other.into().x))
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> AddAssign<T> for Modint<M> {
        fn add_assign(&mut self, other: T) {
            *self = *self + other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> SubAssign<T> for Modint<M> {
        fn sub_assign(&mut self, other: T) {
            *self = *self - other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> MulAssign<T> for Modint<M> {
        fn mul_assign(&mut self, other: T) {
            *self = *self * other;
        }
    }
    impl<M> std::fmt::Display for Modint<M> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            self.x.fmt(f)
        }
    }
    impl<M: Mod> From<i64> for Modint<M> {
        fn from(x: i64) -> Self {
            Self::new((x % M::M as i64) as u64 + M::M)
        }
    }
    impl<M: Mod> From<i32> for Modint<M> {
        fn from(x: i32) -> Self {
            Self::from(x as i64)
        }
    }
    impl<M: Mod> From<usize> for Modint<M> {
        fn from(x: usize) -> Self {
            Self::new(x as u64)
        }
    }
}
const fn _next_power_of_two(mut x: u64) -> u64 {
    x -= 1;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;
    x += 1;
    x
}
macro_rules! define_mod {
    ($ struct_name : ident , $ modulo : expr ) => {
        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
        struct $struct_name {}
        impl modint::Mod for $struct_name {
            const M: u64 = $modulo;
            const S: u64 = {
                let log = Self::M.wrapping_sub(1);
                let log = _next_power_of_two(log).trailing_zeros() as u64;
                let s =
                    [log.wrapping_sub(1), log][Self::M.wrapping_sub(1).is_power_of_two() as usize];
                [s + 64, 0][(Self::M == 1) as usize]
            };
            const X: u64 = {
                let s = Self::S as u32;
                let m = Self::M as u128;
                (((1 as u128).wrapping_shl(s).wrapping_add(m).wrapping_sub(1)) / m) as u64
            };
            fn div(x: u64) -> u64 {
                (((x as u128) * Self::X as u128).wrapping_shr(Self::S as u32)) as u64
            }
            fn modulo(x: u64) -> u64 {
                x.wrapping_sub(Self::div(x) * Self::M)
            }
        }
    };
}
macro_rules! define_mod {
    ($ struct_name : ident , $ modulo : expr ) => {
        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
        struct $struct_name {}
        impl modint::Mod for $struct_name {
            const M: u64 = $modulo;
            fn S() -> u64 {
                if (Self::M - 1).is_power_of_two() {
                    (Self::M - 1).trailing_zeros() as u64
                } else {
                    (Self::M - 1).trailing_zeros() as u64 - 1
                }
            }
            fn X() -> u64 {
                ((((1 as u128) << (Self::S() + 64)) + Self::M as u128 - 1) / Self::M as u128) as u64
            }
        }
    };
}
endsnippet

snippet static_modint_montgomery
mod modint {
    use std::ops::*;
    pub trait Mod: Copy {
        const M: u64;
        fn S() -> u64;
        fn X() -> u64;
    }
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub struct Modint<M> {
        x: u64,
        phantom: std::marker::PhantomData<M>,
    }
    impl<M: Mod> Modint<M> {
        pub fn new(x: u64) -> Self {
            Modint::new_internal(Self::modulo(x))
        }
        fn new_internal(x: u64) -> Self {
            Self {
                x,
                phantom: std::marker::PhantomData,
            }
        }
        fn div(x: u64) -> u64 {
            ((x as u128 * M::X() as u128 >> M::S()) >> 64) as u64
        }
        fn modulo(x: u64) -> u64 {
            x - Self::div(x) * M::M
        }
        pub fn pow(self, mut e: u64) -> Self {
            let mut res = Modint::new_internal(1);
            let mut acc = self;
            while e > 0 {
                if e % 2 != 0 {
                    res *= acc;
                }
                acc *= acc;
                e /= 2;
            }
            res
        }
        pub fn inv(self) -> Self {
            self.pow(M::M - 2)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Add<T> for Modint<M> {
        type Output = Self;
        fn add(self, other: T) -> Self {
            let mut sum = self.x + other.into().x;
            if sum >= M::M {
                sum -= M::M;
            }
            Modint::new_internal(sum)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Sub<T> for Modint<M> {
        type Output = Self;
        fn sub(self, other: T) -> Self {
            let mut diff = self.x as i64 - other.into().x as i64;
            if diff < 0 {
                diff += M::M as i64;
            }
            Modint::new_internal(diff as u64)
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> Mul<T> for Modint<M> {
        type Output = Self;
        fn mul(self, other: T) -> Self {
            Self::new_internal(Self::modulo(self.x * other.into().x))
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> AddAssign<T> for Modint<M> {
        fn add_assign(&mut self, other: T) {
            *self = *self + other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> SubAssign<T> for Modint<M> {
        fn sub_assign(&mut self, other: T) {
            *self = *self - other;
        }
    }
    impl<M: Mod, T: Into<Modint<M>>> MulAssign<T> for Modint<M> {
        fn mul_assign(&mut self, other: T) {
            *self = *self * other;
        }
    }
    impl<M> std::fmt::Display for Modint<M> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            self.x.fmt(f)
        }
    }
    impl<M: Mod> From<i64> for Modint<M> {
        fn from(x: i64) -> Self {
            Self::new((x % M::M) + M::M)
        }
    }
    impl<M: Mod> From<i32> for Modint<M> {
        fn from(x: i32) -> Self {
            Self::new(x as i64)
        }
    }
    impl<M: Mod> From<usize> for Modint<M> {
        fn from(x: usize) -> Self {
            Self::new(x as i64)
        }
    }
}
endsnippet

snippet unionfind
mod unionfind {
    pub struct Unionfind {
        par: Vec<i32>,
        group_count: usize,
    }
    impl Unionfind {
        pub fn new(n: usize) -> Self {
            Unionfind {
                par: vec![-1; n as usize],
                group_count: n as usize,
            }
        }
        fn find_root(&mut self, mut x: usize) -> usize {
            while self.par[x] >= 0 {
                x = self.par[x] as usize;
            }
            x
        }
        pub fn unite(&mut self, x: usize, y: usize) {
            let mut rx = self.find_root(x);
            let mut ry = self.find_root(y);
            if rx == ry {
                return;
            }
            if self.par[rx] > self.par[ry] {
                std::mem::swap(&mut rx, &mut ry);
            }
            self.par[rx] += self.par[ry];
            self.par[ry] = rx as i32;
            self.group_count -= 1;
        }
        pub fn is_same_group(&mut self, x: usize, y: usize) -> bool {
            self.find_root(x) == self.find_root(y)
        }
        pub fn get_group_size(&mut self, x: usize) -> usize {
            let rx = self.find_root(x);
            (-self.par[rx]) as usize
        }
        pub fn get_num_of_groups(&self) -> usize {
            self.group_count
        }
    }
}
endsnippet

