{"message":"`mario` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":122,"byte_end":127,"line_start":5,"line_end":5,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use mario::*;","highlight_start":5,"highlight_end":10}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`mario` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::mario` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`mario` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":852,"byte_end":5765,"line_start":36,"line_end":196,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod mario {","highlight_start":1,"highlight_end":16},{"text":"    pub use crate::read;","highlight_start":1,"highlight_end":25},{"text":"    use std::io;","highlight_start":1,"highlight_end":17},{"text":"    use std::io::{BufRead, BufReader, ErrorKind, Result};","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub mod token {","highlight_start":1,"highlight_end":20},{"text":"        use std::str::FromStr;","highlight_start":1,"highlight_end":31},{"text":"        pub trait Token {","highlight_start":1,"highlight_end":26},{"text":"            type Output;","highlight_start":1,"highlight_end":25},{"text":"            fn parse(s: &str) -> Self::Output;","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<T: FromStr> Token for T {","highlight_start":1,"highlight_end":39},{"text":"            type Output = T;","highlight_start":1,"highlight_end":29},{"text":"            fn parse(s: &str) -> Self::Output {","highlight_start":1,"highlight_end":48},{"text":"                s.parse::<T>().unwrap_or_else(|_| panic!(\"Parse Error\"))","highlight_start":1,"highlight_end":73},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[allow(non_camel_case_types)]","highlight_start":1,"highlight_end":39},{"text":"        pub struct usize1();","highlight_start":1,"highlight_end":29},{"text":"        impl Token for usize1 {","highlight_start":1,"highlight_end":32},{"text":"            type Output = usize;","highlight_start":1,"highlight_end":33},{"text":"            fn parse(s: &str) -> Self::Output {","highlight_start":1,"highlight_end":48},{"text":"                let i = s.parse::<usize>().unwrap_or_else(|_| panic!(\"Parse Error\"));","highlight_start":1,"highlight_end":86},{"text":"                i.checked_sub(1).unwrap()","highlight_start":1,"highlight_end":42},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[allow(non_camel_case_types)]","highlight_start":1,"highlight_end":39},{"text":"        pub struct isize1();","highlight_start":1,"highlight_end":29},{"text":"        impl Token for isize1 {","highlight_start":1,"highlight_end":32},{"text":"            type Output = isize;","highlight_start":1,"highlight_end":33},{"text":"            fn parse(s: &str) -> Self::Output {","highlight_start":1,"highlight_end":48},{"text":"                let i = s.parse::<isize>().unwrap_or_else(|_| panic!(\"Parse Error\"));","highlight_start":1,"highlight_end":86},{"text":"                i.checked_sub(1).unwrap()","highlight_start":1,"highlight_end":42},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    use token::Token;","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn read_until_whitespace<R: BufRead + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {","highlight_start":1,"highlight_end":99},{"text":"        let mut read = 0;","highlight_start":1,"highlight_end":26},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let (done, used) = {","highlight_start":1,"highlight_end":33},{"text":"                let available = match r.fill_buf() {","highlight_start":1,"highlight_end":53},{"text":"                    Ok(n) => n,","highlight_start":1,"highlight_end":32},{"text":"                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,","highlight_start":1,"highlight_end":82},{"text":"                    Err(e) => return Err(e),","highlight_start":1,"highlight_end":45},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                match available","highlight_start":1,"highlight_end":32},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .enumerate()","highlight_start":1,"highlight_end":33},{"text":"                    .find(|(_, x)| x.is_ascii_whitespace())","highlight_start":1,"highlight_end":60},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    Some((i, _)) => {","highlight_start":1,"highlight_end":38},{"text":"                        buf.extend_from_slice(&available[..=i]);","highlight_start":1,"highlight_end":65},{"text":"                        (true, i + 1)","highlight_start":1,"highlight_end":38},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    None => {","highlight_start":1,"highlight_end":30},{"text":"                        buf.extend_from_slice(available);","highlight_start":1,"highlight_end":58},{"text":"                        (false, available.len())","highlight_start":1,"highlight_end":49},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"            r.consume(used);","highlight_start":1,"highlight_end":29},{"text":"            read += used;","highlight_start":1,"highlight_end":26},{"text":"            if done || used == 0 {","highlight_start":1,"highlight_end":35},{"text":"                return Ok(read);","highlight_start":1,"highlight_end":33},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    macro_rules! prim_method {","highlight_start":1,"highlight_end":31},{"text":"        ($name:ident: $T:ty) => {","highlight_start":1,"highlight_end":34},{"text":"            pub fn $name(&mut self) -> $T {","highlight_start":1,"highlight_end":44},{"text":"                self.parse::<$T>()","highlight_start":1,"highlight_end":35},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($name:ident) => {","highlight_start":1,"highlight_end":27},{"text":"            prim_method!($name: $name);","highlight_start":1,"highlight_end":40},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    macro_rules! prim_methods {","highlight_start":1,"highlight_end":32},{"text":"        ($name:ident: $T:ty; $($rest:tt)*) => {","highlight_start":1,"highlight_end":48},{"text":"            prim_method!($name:$T);","highlight_start":1,"highlight_end":36},{"text":"            prim_methods!($($rest)*);","highlight_start":1,"highlight_end":38},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($name:ident; $($rest:tt)*) => {","highlight_start":1,"highlight_end":41},{"text":"            prim_method!($name);","highlight_start":1,"highlight_end":33},{"text":"            prim_methods!($($rest)*);","highlight_start":1,"highlight_end":38},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        () => ()","highlight_start":1,"highlight_end":17},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // MARimo + IO -> MarIo","highlight_start":1,"highlight_end":28},{"text":"    // work as a tokenizer.","highlight_start":1,"highlight_end":28},{"text":"    pub struct MarIo<I: BufRead> {","highlight_start":1,"highlight_end":35},{"text":"        reader: I,","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<I: BufRead> MarIo<I> {","highlight_start":1,"highlight_end":32},{"text":"        pub fn new(reader: I) -> Self {","highlight_start":1,"highlight_end":40},{"text":"            Self { reader }","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn token(&mut self) -> String {","highlight_start":1,"highlight_end":40},{"text":"            let mut buf = Vec::new();","highlight_start":1,"highlight_end":38},{"text":"            loop {","highlight_start":1,"highlight_end":19},{"text":"                buf.clear();","highlight_start":1,"highlight_end":29},{"text":"                read_until_whitespace(&mut self.reader, &mut buf)","highlight_start":1,"highlight_end":66},{"text":"                    .expect(\"困ってしまいましたね。どうやら入力がうまくいかないようです。\");","highlight_start":1,"highlight_end":63},{"text":"                let len = buf.len();","highlight_start":1,"highlight_end":37},{"text":"                match len {","highlight_start":1,"highlight_end":28},{"text":"                    0 => panic!(\"もう入力終わってますよ。\"),","highlight_start":1,"highlight_end":49},{"text":"                    1 if buf[0].is_ascii_whitespace() => (),","highlight_start":1,"highlight_end":61},{"text":"                    _ => {","highlight_start":1,"highlight_end":27},{"text":"                        if buf[len - 1].is_ascii_whitespace() {","highlight_start":1,"highlight_end":64},{"text":"                            buf.truncate(len - 1);","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        break;","highlight_start":1,"highlight_end":31},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            unsafe { String::from_utf8_unchecked(buf) }","highlight_start":1,"highlight_end":56},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn parse<T: Token>(&mut self) -> T::Output {","highlight_start":1,"highlight_end":57},{"text":"            T::parse(&self.token())","highlight_start":1,"highlight_end":36},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        prim_methods! {","highlight_start":1,"highlight_end":24},{"text":"            u8; u16; u32; u64; u128; usize;","highlight_start":1,"highlight_end":44},{"text":"            i8; i16; i32; i64; i128; isize;","highlight_start":1,"highlight_end":44},{"text":"            f32; f64;","highlight_start":1,"highlight_end":22},{"text":"            char; string: String;","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // MarIo with stdin/out","highlight_start":1,"highlight_end":28},{"text":"    impl MarIo<BufReader<io::Stdin>> {","highlight_start":1,"highlight_end":39},{"text":"        pub fn new_stdio() -> Self {","highlight_start":1,"highlight_end":37},{"text":"            Self::new(BufReader::new(io::stdin()))","highlight_start":1,"highlight_end":51},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! read {","highlight_start":1,"highlight_end":24},{"text":"        ($stdin:ident: [char]) => {","highlight_start":1,"highlight_end":36},{"text":"            $stdin.string().chars().collect::<Vec<_>>()","highlight_start":1,"highlight_end":56},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($stdin:ident: [u8]) => {","highlight_start":1,"highlight_end":34},{"text":"            $stdin.string().bytes().collect::<Vec<_>>()","highlight_start":1,"highlight_end":56},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($stdin:ident: [$($t:tt),*; $n:expr]) => {","highlight_start":1,"highlight_end":51},{"text":"            (0..$n).map(|_| ($(read!($stdin: $t)),*)).collect::<Vec<_>>()","highlight_start":1,"highlight_end":74},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($stdin:ident: $t:ty) => {","highlight_start":1,"highlight_end":35},{"text":"            $stdin.parse::<$t>()","highlight_start":1,"highlight_end":33},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($stdin:ident: $($t:ty),+) => {","highlight_start":1,"highlight_end":40},{"text":"            ($(read!($stdin: $t)),*)","highlight_start":1,"highlight_end":37},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::mario` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `mario` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:5:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse mario::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `mario` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::mario` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `mario` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:36:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod mario {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::read;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io::{BufRead, BufReader, ErrorKind, Result};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m196\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::mario` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0659`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0659`.\u001b[0m\n"}
