{"message":"`algebra` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":437,"byte_end":444,"line_start":8,"line_end":8,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use algebra::*;","highlight_start":5,"highlight_end":12}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`algebra` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::algebra` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`algebra` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":2436,"byte_end":6735,"line_start":92,"line_end":247,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod algebra {","highlight_start":1,"highlight_end":18},{"text":"    pub use crate::{def_monoid, impl_monoid};","highlight_start":1,"highlight_end":46},{"text":"    use std::{fmt, ops};","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Element: Sized + Clone + PartialEq + fmt::Debug {}","highlight_start":1,"highlight_end":65},{"text":"    impl<T: Sized + Clone + PartialEq + fmt::Debug> Element for T {}","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Zero: ops::Add<Output = Self> + ops::AddAssign + Element {","highlight_start":1,"highlight_end":73},{"text":"        fn zero() -> Self;","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait One: ops::Mul<Output = Self> + ops::MulAssign + Element {","highlight_start":1,"highlight_end":72},{"text":"        fn one() -> Self;","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Ring: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign {}","highlight_start":1,"highlight_end":88},{"text":"    impl<T: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign> Ring for T {}","highlight_start":1,"highlight_end":92},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Magma: Element {","highlight_start":1,"highlight_end":31},{"text":"        fn op(lhs: Self, rhs: Self) -> Self;","highlight_start":1,"highlight_end":45},{"text":"        fn op_from_left(&mut self, left: Self) {","highlight_start":1,"highlight_end":49},{"text":"            *self = Self::op(left, self.clone());","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn op_from_right(&mut self, right: Self) {","highlight_start":1,"highlight_end":51},{"text":"            *self = Self::op(self.clone(), right);","highlight_start":1,"highlight_end":51},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Semigroup: Magma {}","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Identity {","highlight_start":1,"highlight_end":25},{"text":"        fn identity() -> Self;","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Quasigroup: Magma {","highlight_start":1,"highlight_end":34},{"text":"        fn inv(self) -> Self;","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Loop: Quasigroup + Identity {}","highlight_start":1,"highlight_end":45},{"text":"    impl<T: Quasigroup + Identity> Loop for T {}","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Monoid: Semigroup + Identity {}","highlight_start":1,"highlight_end":46},{"text":"    impl<T: Semigroup + Identity> Monoid for T {}","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Commut: Semigroup {}","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Group: Monoid + Loop {}","highlight_start":1,"highlight_end":38},{"text":"    impl<T: Monoid + Loop> Group for T {}","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Abel: Group {}","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! def_monoid {","highlight_start":1,"highlight_end":30},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            derive($($attr: meta),*),","highlight_start":1,"highlight_end":38},{"text":"            $pub:vis struct $name:ident {","highlight_start":1,"highlight_end":42},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $field_vis:vis $field_name:ident : $field_type:ty","highlight_start":1,"highlight_end":70},{"text":"                ),*$(,)*","highlight_start":1,"highlight_end":25},{"text":"            }, ","highlight_start":1,"highlight_end":16},{"text":"            $identity:expr, $op:item","highlight_start":1,"highlight_end":37},{"text":"        ) => {","highlight_start":1,"highlight_end":15},{"text":"            #[derive(Debug, Clone, PartialEq, $($attr),*)]","highlight_start":1,"highlight_end":59},{"text":"            $pub struct $name {","highlight_start":1,"highlight_end":32},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $field_vis $field_name : $field_type","highlight_start":1,"highlight_end":57},{"text":"                ),*","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            impl_monoid!{$name, $identity, $op}","highlight_start":1,"highlight_end":48},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            derive($($attr: meta),*), ","highlight_start":1,"highlight_end":39},{"text":"            $pub: vis struct $name: ident (","highlight_start":1,"highlight_end":44},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $field_vis: vis $field_type: ty","highlight_start":1,"highlight_end":52},{"text":"                ),*","highlight_start":1,"highlight_end":20},{"text":"            ), ","highlight_start":1,"highlight_end":16},{"text":"            $identity: expr, $op: item","highlight_start":1,"highlight_end":39},{"text":"        ) => {","highlight_start":1,"highlight_end":15},{"text":"            #[derive(Debug, Clone, PartialEq, $($attr),*)]","highlight_start":1,"highlight_end":59},{"text":"            $pub struct $name (","highlight_start":1,"highlight_end":32},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $field_vis $field_type","highlight_start":1,"highlight_end":43},{"text":"                ),*","highlight_start":1,"highlight_end":20},{"text":"            );","highlight_start":1,"highlight_end":15},{"text":"            impl_monoid!{$name, $identity, $op}","highlight_start":1,"highlight_end":48},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! impl_monoid {","highlight_start":1,"highlight_end":31},{"text":"        ($name: ident, $identity: expr, $op: item) => {","highlight_start":1,"highlight_end":56},{"text":"            impl Magma for $name {","highlight_start":1,"highlight_end":35},{"text":"                $op","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            impl Semigroup for $name {}","highlight_start":1,"highlight_end":40},{"text":"            impl Identity for $name {","highlight_start":1,"highlight_end":38},{"text":"                fn identity() -> Self {","highlight_start":1,"highlight_end":40},{"text":"                    $identity","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    macro_rules! impl_one_integer {","highlight_start":1,"highlight_end":36},{"text":"        ($t: ty) => {","highlight_start":1,"highlight_end":22},{"text":"            impl One for $t {","highlight_start":1,"highlight_end":30},{"text":"                fn one() -> Self {","highlight_start":1,"highlight_end":35},{"text":"                    1 as $t","highlight_start":1,"highlight_end":28},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            $(impl_one_integer!($t);)+","highlight_start":1,"highlight_end":39},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    macro_rules! impl_zero_integer {","highlight_start":1,"highlight_end":37},{"text":"        ($t: ty) => {","highlight_start":1,"highlight_end":22},{"text":"            impl Zero for $t {","highlight_start":1,"highlight_end":31},{"text":"                fn zero() -> Self {","highlight_start":1,"highlight_end":36},{"text":"                    0 as $t","highlight_start":1,"highlight_end":28},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            $(impl_zero_integer!($t);)+","highlight_start":1,"highlight_end":40},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    macro_rules! impl_abel_integer {","highlight_start":1,"highlight_end":37},{"text":"        ($t: ty) => {","highlight_start":1,"highlight_end":22},{"text":"            impl Magma for $t {","highlight_start":1,"highlight_end":32},{"text":"                fn op(lhs: Self, rhs: Self) ->Self {","highlight_start":1,"highlight_end":53},{"text":"                    lhs + rhs","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            impl Semigroup for $t {}","highlight_start":1,"highlight_end":37},{"text":"            impl Identity for $t {","highlight_start":1,"highlight_end":35},{"text":"                fn identity() -> Self {","highlight_start":1,"highlight_end":40},{"text":"                    0 as $t","highlight_start":1,"highlight_end":28},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            impl Quasigroup for $t {","highlight_start":1,"highlight_end":37},{"text":"                fn inv(self) -> Self {","highlight_start":1,"highlight_end":39},{"text":"                    -self","highlight_start":1,"highlight_end":26},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            impl Abel for $t {}","highlight_start":1,"highlight_end":32},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            $(impl_abel_integer!($t);)+","highlight_start":1,"highlight_end":40},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl_one_integer!(i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, usize);","highlight_start":1,"highlight_end":80},{"text":"    impl_zero_integer!(i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, usize);","highlight_start":1,"highlight_end":81},{"text":"    impl_abel_integer!(i8, i16, i32, i64, i128);","highlight_start":1,"highlight_end":49},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::algebra` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `algebra` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:8:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse algebra::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `algebra` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::algebra` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `algebra` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:92:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod algebra {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::{def_monoid, impl_monoid};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::{fmt, ops};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl_abel_integer!(i8, i16, i32, i64, i128);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::algebra` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`lazy_segment_tree` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":453,"byte_end":470,"line_start":9,"line_end":9,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use lazy_segment_tree::*;","highlight_start":5,"highlight_end":22}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`lazy_segment_tree` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::lazy_segment_tree` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`lazy_segment_tree` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":6754,"byte_end":10554,"line_start":250,"line_end":367,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod lazy_segment_tree {","highlight_start":1,"highlight_end":28},{"text":"    //ATTENTION","highlight_start":1,"highlight_end":16},{"text":"    //まだです。","highlight_start":1,"highlight_end":12},{"text":"    mod __pseudo_extern_prelude {","highlight_start":1,"highlight_end":34},{"text":"        pub(super) use crate::algebra;","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    use algebra::*;","highlight_start":1,"highlight_end":20},{"text":"    use std::ops::Range;","highlight_start":1,"highlight_end":25},{"text":"    #[derive(Debug, Clone)]","highlight_start":1,"highlight_end":28},{"text":"    pub struct LazySegmentTree<T, E>","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        T: Monoid,","highlight_start":1,"highlight_end":19},{"text":"        E: Monoid,","highlight_start":1,"highlight_end":19},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        data: Box<[T]>,","highlight_start":1,"highlight_end":24},{"text":"        lazy: Box<[E]>,","highlight_start":1,"highlight_end":24},{"text":"        affecter: fn(T, E) -> T,","highlight_start":1,"highlight_end":33},{"text":"        len: usize,","highlight_start":1,"highlight_end":20},{"text":"        log: usize,","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T, E> LazySegmentTree<T, E>","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        T: Monoid + Copy,","highlight_start":1,"highlight_end":26},{"text":"        E: Monoid + Copy,","highlight_start":1,"highlight_end":26},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        fn propagate(&mut self, k: usize) {","highlight_start":1,"highlight_end":44},{"text":"            self.apply(k << 1, self.lazy[k]);","highlight_start":1,"highlight_end":46},{"text":"            self.apply((k << 1) + 1, self.lazy[k]);","highlight_start":1,"highlight_end":52},{"text":"            self.lazy[k] = E::identity();","highlight_start":1,"highlight_end":42},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn apply(&mut self, k: usize, e: E) {","highlight_start":1,"highlight_end":46},{"text":"            self.data[k] = (self.affecter)(self.data[k], e);","highlight_start":1,"highlight_end":61},{"text":"            self.lazy[k] = E::op(self.lazy[k], e);","highlight_start":1,"highlight_end":51},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn recalc(&mut self, k: usize) {","highlight_start":1,"highlight_end":41},{"text":"            let mut k = k >> (k.trailing_zeros() as usize);","highlight_start":1,"highlight_end":60},{"text":"            k >>= 1;","highlight_start":1,"highlight_end":21},{"text":"            while k != 0 {","highlight_start":1,"highlight_end":27},{"text":"                self.data[k] = T::op(self.data[k << 1], self.data[(k << 1) + 1]);","highlight_start":1,"highlight_end":82},{"text":"                k >>= 1;","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn thrust(&mut self, k: usize) {","highlight_start":1,"highlight_end":41},{"text":"            (1..=self.log).rev().for_each(|i| self.propagate(k >> i));","highlight_start":1,"highlight_end":71},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn new(len: usize, affecter: fn(T, E) -> T) -> Self {","highlight_start":1,"highlight_end":66},{"text":"            let len = len.next_power_of_two();","highlight_start":1,"highlight_end":47},{"text":"            let height = len.trailing_zeros() as usize;","highlight_start":1,"highlight_end":56},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                data: vec![T::identity(); 2 * len].into_boxed_slice(),","highlight_start":1,"highlight_end":71},{"text":"                lazy: vec![E::identity(); 2 * len].into_boxed_slice(),","highlight_start":1,"highlight_end":71},{"text":"                affecter,","highlight_start":1,"highlight_end":26},{"text":"                len,","highlight_start":1,"highlight_end":21},{"text":"                log: height,","highlight_start":1,"highlight_end":29},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn new_with_init(initializer: &[T], affecter: fn(T, E) -> T) -> Self {","highlight_start":1,"highlight_end":83},{"text":"            let len = initializer.len().next_power_of_two();","highlight_start":1,"highlight_end":61},{"text":"            let mut data = vec![T::identity(); 2 * len].into_boxed_slice();","highlight_start":1,"highlight_end":76},{"text":"            for (idx, val) in initializer.iter().enumerate() {","highlight_start":1,"highlight_end":63},{"text":"                data[idx + len] = val.clone();","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            for i in (1..len).rev() {","highlight_start":1,"highlight_end":38},{"text":"                data[i] = T::op(data[i << 1], data[(i << 1) + 1]);","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                data,","highlight_start":1,"highlight_end":22},{"text":"                lazy: vec![E::identity(); 2 * len].into_boxed_slice(),","highlight_start":1,"highlight_end":71},{"text":"                affecter,","highlight_start":1,"highlight_end":26},{"text":"                len,","highlight_start":1,"highlight_end":21},{"text":"                log: len.trailing_zeros() as usize,","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn update(&mut self, q: Range<usize>, x: E) {","highlight_start":1,"highlight_end":58},{"text":"            let (mut l, mut r) = (q.start + self.len, q.end + self.len);","highlight_start":1,"highlight_end":73},{"text":"            self.thrust(l);","highlight_start":1,"highlight_end":28},{"text":"            self.thrust(r - 1);","highlight_start":1,"highlight_end":32},{"text":"            while l < r {","highlight_start":1,"highlight_end":26},{"text":"                if l & 1 != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    self.apply(l, x);","highlight_start":1,"highlight_end":38},{"text":"                    l += 1;","highlight_start":1,"highlight_end":28},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if r & 1 != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    r -= 1;","highlight_start":1,"highlight_end":28},{"text":"                    self.apply(r, x);","highlight_start":1,"highlight_end":38},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                l >>= 1;","highlight_start":1,"highlight_end":25},{"text":"                r >>= 1;","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            self.recalc(q.start + self.len);","highlight_start":1,"highlight_end":45},{"text":"            self.recalc(q.end + self.len);","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn query(&mut self, q: Range<usize>) -> T {","highlight_start":1,"highlight_end":56},{"text":"            let (mut l, mut r) = (q.start + self.len, q.end + self.len);","highlight_start":1,"highlight_end":73},{"text":"            self.thrust(l);","highlight_start":1,"highlight_end":28},{"text":"            self.thrust(r - 1);","highlight_start":1,"highlight_end":32},{"text":"            let (mut fl, mut fr) = (T::identity(), T::identity());","highlight_start":1,"highlight_end":67},{"text":"            while l < r {","highlight_start":1,"highlight_end":26},{"text":"                if l & 1 != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    fl = T::op(fl, self.data[l]);","highlight_start":1,"highlight_end":50},{"text":"                    l += 1;","highlight_start":1,"highlight_end":28},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if r & 1 != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    r -= 1;","highlight_start":1,"highlight_end":28},{"text":"                    fr = T::op(self.data[r], fr);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                l >>= 1;","highlight_start":1,"highlight_end":25},{"text":"                r >>= 1;","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            T::op(fl, fr)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn len(&self) -> usize {","highlight_start":1,"highlight_end":37},{"text":"            self.len","highlight_start":1,"highlight_end":21},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::lazy_segment_tree` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `lazy_segment_tree` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:9:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse lazy_segment_tree::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `lazy_segment_tree` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::lazy_segment_tree` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `lazy_segment_tree` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:250:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m250\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod lazy_segment_tree {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    //ATTENTION\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    //まだです。\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m253\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    mod __pseudo_extern_prelude {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m366\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m367\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::lazy_segment_tree` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`scanner` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":479,"byte_end":486,"line_start":10,"line_end":10,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use scanner::*;","highlight_start":5,"highlight_end":12}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`scanner` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::scanner` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`scanner` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":10573,"byte_end":13132,"line_start":370,"line_end":468,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod scanner {","highlight_start":1,"highlight_end":18},{"text":"    pub use crate::scan;","highlight_start":1,"highlight_end":25},{"text":"    use std::io::BufRead;","highlight_start":1,"highlight_end":26},{"text":"    use std::str::{FromStr, SplitWhitespace};","highlight_start":1,"highlight_end":46},{"text":"    use std::thread_local;","highlight_start":1,"highlight_end":27},{"text":"    use std::{cell::RefCell, io};","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Readable {","highlight_start":1,"highlight_end":25},{"text":"        type Output;","highlight_start":1,"highlight_end":21},{"text":"        fn read(input: &str) -> Self::Output;","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: FromStr> Readable for T {","highlight_start":1,"highlight_end":38},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse().ok().unwrap()","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    struct Tokenizer<T: BufRead> {","highlight_start":1,"highlight_end":35},{"text":"        source: T,","highlight_start":1,"highlight_end":19},{"text":"        token: SplitWhitespace<'static>,","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Tokenizer<T> {","highlight_start":1,"highlight_end":36},{"text":"        fn read(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"            self.source","highlight_start":1,"highlight_end":24},{"text":"                .read_line(&mut line)","highlight_start":1,"highlight_end":38},{"text":"                .expect(\"an IO error occured\");","highlight_start":1,"highlight_end":48},{"text":"            self.token = Box::leak(line.into_boxed_str()).split_whitespace();","highlight_start":1,"highlight_end":78},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn next(&mut self) -> &str {","highlight_start":1,"highlight_end":37},{"text":"            if let Some(x) = self.token.next() {","highlight_start":1,"highlight_end":49},{"text":"                x","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                self.read();","highlight_start":1,"highlight_end":29},{"text":"                self.next()","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub struct Scanner<T: BufRead> {","highlight_start":1,"highlight_end":37},{"text":"        tokenizer: Tokenizer<T>,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Scanner<T> {","highlight_start":1,"highlight_end":34},{"text":"        pub fn new(source: T) -> Self {","highlight_start":1,"highlight_end":40},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                tokenizer: Tokenizer {","highlight_start":1,"highlight_end":39},{"text":"                    source,","highlight_start":1,"highlight_end":28},{"text":"                    token: \"\".split_whitespace(),","highlight_start":1,"highlight_end":50},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn scan<U: Readable>(&mut self) -> U::Output {","highlight_start":1,"highlight_end":59},{"text":"            U::read(self.tokenizer.next())","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    thread_local! (","highlight_start":1,"highlight_end":20},{"text":"        pub static STDIN: RefCell<Scanner<std::io::StdinLock<'static>>> = {","highlight_start":1,"highlight_end":76},{"text":"            let stdin = Box::leak(Box::new(io::stdin()));","highlight_start":1,"highlight_end":58},{"text":"            RefCell::new(Scanner::new(stdin.lock()))","highlight_start":1,"highlight_end":53},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! scan {","highlight_start":1,"highlight_end":24},{"text":"        ([char]) => {","highlight_start":1,"highlight_end":22},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().chars().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([u8]) => {","highlight_start":1,"highlight_end":20},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().bytes().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([$($t:tt),*; $n:expr]) => {","highlight_start":1,"highlight_end":37},{"text":"            (0..$n).map(|_| ($(scan!($t)),*)).collect::<Vec<_>>()","highlight_start":1,"highlight_end":66},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($t:ty) => {","highlight_start":1,"highlight_end":21},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<$t>())","highlight_start":1,"highlight_end":64},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            ($(scan!($t)),*)","highlight_start":1,"highlight_end":29},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(non_camel_case_types)]","highlight_start":1,"highlight_end":35},{"text":"    pub struct usize1();","highlight_start":1,"highlight_end":25},{"text":"    impl Readable for usize1 {","highlight_start":1,"highlight_end":31},{"text":"        type Output = usize;","highlight_start":1,"highlight_end":29},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse::<usize>().unwrap() - 1","highlight_start":1,"highlight_end":48},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::scanner` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `scanner` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:10:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse scanner::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `scanner` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::scanner` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `scanner` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:370:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod scanner {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m371\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::scan;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m372\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io::BufRead;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m373\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::str::{FromStr, SplitWhitespace};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m467\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::scanner` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`static_modint` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":495,"byte_end":508,"line_start":11,"line_end":11,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use static_modint::*;","highlight_start":5,"highlight_end":18}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`static_modint` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::static_modint` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`static_modint` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":13151,"byte_end":18899,"line_start":471,"line_end":704,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod static_modint {","highlight_start":1,"highlight_end":24},{"text":"    mod __pseudo_extern_prelude {","highlight_start":1,"highlight_end":34},{"text":"        pub(super) use crate::algebra;","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub use crate::define_mod;","highlight_start":1,"highlight_end":31},{"text":"    use algebra::{One, Zero};","highlight_start":1,"highlight_end":30},{"text":"    use std::{num::ParseIntError, ops::*, str::FromStr};","highlight_start":1,"highlight_end":57},{"text":"    pub trait Mod: Copy + std::fmt::Debug + PartialEq {","highlight_start":1,"highlight_end":56},{"text":"        const M: u64;","highlight_start":1,"highlight_end":22},{"text":"        const S: u64;","highlight_start":1,"highlight_end":22},{"text":"        const X: u128;","highlight_start":1,"highlight_end":23},{"text":"        fn div(x: u64) -> u64;","highlight_start":1,"highlight_end":31},{"text":"        fn modulo(x: u64) -> u64;","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]","highlight_start":1,"highlight_end":72},{"text":"    pub struct Modint<M> {","highlight_start":1,"highlight_end":27},{"text":"        x: u64,","highlight_start":1,"highlight_end":16},{"text":"        phantom: std::marker::PhantomData<M>,","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> Modint<M> {","highlight_start":1,"highlight_end":29},{"text":"        pub fn new(x: u64) -> Self {","highlight_start":1,"highlight_end":37},{"text":"            Modint::new_internal(M::modulo(x))","highlight_start":1,"highlight_end":47},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn new_internal(x: u64) -> Self {","highlight_start":1,"highlight_end":42},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                x,","highlight_start":1,"highlight_end":19},{"text":"                phantom: std::marker::PhantomData,","highlight_start":1,"highlight_end":51},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        #[inline(always)]","highlight_start":1,"highlight_end":26},{"text":"        pub fn value(self) -> u64 {","highlight_start":1,"highlight_end":36},{"text":"            self.x","highlight_start":1,"highlight_end":19},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn pow(self, mut e: u64) -> Self {","highlight_start":1,"highlight_end":47},{"text":"            let mut res = Modint::one();","highlight_start":1,"highlight_end":41},{"text":"            let mut acc = self;","highlight_start":1,"highlight_end":32},{"text":"            e = M::div(e) + M::modulo(e);","highlight_start":1,"highlight_end":42},{"text":"            while e > 0 {","highlight_start":1,"highlight_end":26},{"text":"                if e & 1 == 1 {","highlight_start":1,"highlight_end":32},{"text":"                    res *= acc;","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                acc *= acc;","highlight_start":1,"highlight_end":28},{"text":"                e >>= 1;","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            res","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        pub fn inv(self) -> Self {","highlight_start":1,"highlight_end":35},{"text":"            self.pow(M::M - 2)","highlight_start":1,"highlight_end":31},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> Neg for Modint<M> {","highlight_start":1,"highlight_end":37},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn neg(self) -> Self::Output {","highlight_start":1,"highlight_end":39},{"text":"            self * Self::new_internal(M::M - 1)","highlight_start":1,"highlight_end":48},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    // {{{ operation","highlight_start":1,"highlight_end":21},{"text":"    // {{{ binary operation","highlight_start":1,"highlight_end":28},{"text":"    impl<M: Mod, T: Into<Modint<M>>> Add<T> for Modint<M> {","highlight_start":1,"highlight_end":60},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn add(mut self, rhs: T) -> Self {","highlight_start":1,"highlight_end":43},{"text":"            self.add_assign(rhs);","highlight_start":1,"highlight_end":34},{"text":"            self","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod, T: Into<Modint<M>>> Sub<T> for Modint<M> {","highlight_start":1,"highlight_end":60},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn sub(mut self, rhs: T) -> Self {","highlight_start":1,"highlight_end":43},{"text":"            self.sub_assign(rhs);","highlight_start":1,"highlight_end":34},{"text":"            self","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod, T: Into<Modint<M>>> Mul<T> for Modint<M> {","highlight_start":1,"highlight_end":60},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn mul(mut self, rhs: T) -> Self {","highlight_start":1,"highlight_end":43},{"text":"            self.mul_assign(rhs);","highlight_start":1,"highlight_end":34},{"text":"            self","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    // }}}","highlight_start":1,"highlight_end":11},{"text":"    // {{{ compound","highlight_start":1,"highlight_end":20},{"text":"    impl<M: Mod, T: Into<Modint<M>>> AddAssign<T> for Modint<M> {","highlight_start":1,"highlight_end":66},{"text":"        fn add_assign(&mut self, rhs: T) {","highlight_start":1,"highlight_end":43},{"text":"            self.x += rhs.into().x;","highlight_start":1,"highlight_end":36},{"text":"            if self.x >= M::M {","highlight_start":1,"highlight_end":32},{"text":"                self.x -= M::M;","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod, T: Into<Modint<M>>> SubAssign<T> for Modint<M> {","highlight_start":1,"highlight_end":66},{"text":"        fn sub_assign(&mut self, rhs: T) {","highlight_start":1,"highlight_end":43},{"text":"            let rhs = rhs.into();","highlight_start":1,"highlight_end":34},{"text":"            if self.x < rhs.x {","highlight_start":1,"highlight_end":32},{"text":"                self.x += M::M;","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            self.x -= rhs.x;","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod, T: Into<Modint<M>>> MulAssign<T> for Modint<M> {","highlight_start":1,"highlight_end":66},{"text":"        fn mul_assign(&mut self, rhs: T) {","highlight_start":1,"highlight_end":43},{"text":"            self.x *= rhs.into().x;","highlight_start":1,"highlight_end":36},{"text":"            self.x = M::modulo(self.x);","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    // }}}","highlight_start":1,"highlight_end":11},{"text":"    // }}}","highlight_start":1,"highlight_end":11},{"text":"    impl<M: Mod> std::fmt::Display for Modint<M> {","highlight_start":1,"highlight_end":51},{"text":"        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {","highlight_start":1,"highlight_end":73},{"text":"            self.x.fmt(f)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    // {{{ from","highlight_start":1,"highlight_end":16},{"text":"    impl<M: Mod> From<i64> for Modint<M> {","highlight_start":1,"highlight_end":43},{"text":"        fn from(x: i64) -> Self {","highlight_start":1,"highlight_end":34},{"text":"            Self::new((x % M::M as i64) as u64 + M::M)","highlight_start":1,"highlight_end":55},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> From<i32> for Modint<M> {","highlight_start":1,"highlight_end":43},{"text":"        fn from(x: i32) -> Self {","highlight_start":1,"highlight_end":34},{"text":"            Self::from(x as i64)","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> From<u32> for Modint<M> {","highlight_start":1,"highlight_end":43},{"text":"        fn from(x: u32) -> Self {","highlight_start":1,"highlight_end":34},{"text":"            Self::new(x as u64)","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> From<usize> for Modint<M> {","highlight_start":1,"highlight_end":45},{"text":"        fn from(x: usize) -> Self {","highlight_start":1,"highlight_end":36},{"text":"            Self::new(x as u64)","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> FromStr for Modint<M> {","highlight_start":1,"highlight_end":41},{"text":"        type Err = ParseIntError;","highlight_start":1,"highlight_end":34},{"text":"        fn from_str(s: &str) -> Result<Self, Self::Err> {","highlight_start":1,"highlight_end":58},{"text":"            let x = s.parse::<u64>()?;","highlight_start":1,"highlight_end":39},{"text":"            Ok(Self::new(x))","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    //}}}","highlight_start":1,"highlight_end":10},{"text":"    impl<M: Mod> Zero for Modint<M> {","highlight_start":1,"highlight_end":38},{"text":"        fn zero() -> Self {","highlight_start":1,"highlight_end":28},{"text":"            Self::new_internal(0)","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<M: Mod> One for Modint<M> {","highlight_start":1,"highlight_end":37},{"text":"        fn one() -> Self {","highlight_start":1,"highlight_end":27},{"text":"            Self::new_internal(1)","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    const fn _next_power_of_two(mut x: u64) -> u64 {","highlight_start":1,"highlight_end":53},{"text":"        x -= 1;","highlight_start":1,"highlight_end":16},{"text":"        x |= x >> 1;","highlight_start":1,"highlight_end":21},{"text":"        x |= x >> 2;","highlight_start":1,"highlight_end":21},{"text":"        x |= x >> 4;","highlight_start":1,"highlight_end":21},{"text":"        x |= x >> 8;","highlight_start":1,"highlight_end":21},{"text":"        x |= x >> 16;","highlight_start":1,"highlight_end":22},{"text":"        x |= x >> 32;","highlight_start":1,"highlight_end":22},{"text":"        x += 1;","highlight_start":1,"highlight_end":16},{"text":"        x","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub const fn _calc_s(m: u64) -> u64 {","highlight_start":1,"highlight_end":42},{"text":"        let log = m.wrapping_sub(1);","highlight_start":1,"highlight_end":37},{"text":"        let log = _next_power_of_two(log).trailing_zeros() as u64;","highlight_start":1,"highlight_end":67},{"text":"        let s = [log.wrapping_sub(1), log][m.wrapping_sub(1).is_power_of_two() as usize];","highlight_start":1,"highlight_end":90},{"text":"        [s + 64, 0][(m == 1) as usize]","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! define_mod {","highlight_start":1,"highlight_end":30},{"text":"        ($struct_name:ident, $modulo:expr) => {","highlight_start":1,"highlight_end":48},{"text":"            #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]","highlight_start":1,"highlight_end":80},{"text":"            pub struct $struct_name {}","highlight_start":1,"highlight_end":39},{"text":"            impl Mod for $struct_name {","highlight_start":1,"highlight_end":40},{"text":"                const M: u64 = $modulo;","highlight_start":1,"highlight_end":40},{"text":"                const S: u64 = $crate::static_modint::_calc_s(Self::M);","highlight_start":1,"highlight_end":72},{"text":"                const X: u128 = {","highlight_start":1,"highlight_end":34},{"text":"                    let s = Self::S as u32;","highlight_start":1,"highlight_end":44},{"text":"                    let m = Self::M as u128;","highlight_start":1,"highlight_end":45},{"text":"                    ((1 as u128).wrapping_shl(s).wrapping_add(m).wrapping_sub(1)) / m","highlight_start":1,"highlight_end":86},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                fn div(x: u64) -> u64 {","highlight_start":1,"highlight_end":40},{"text":"                    (((x as u128) * Self::X).wrapping_shr(Self::S as u32)) as u64","highlight_start":1,"highlight_end":82},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                fn modulo(x: u64) -> u64 {","highlight_start":1,"highlight_end":43},{"text":"                    x.wrapping_sub(Self::div(x) * Self::M)","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // 逆数乗算","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    define_mod!(P1000000007, 1_000_000_007);","highlight_start":1,"highlight_end":45},{"text":"    define_mod!(P998244353, 998244353);","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::static_modint` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `static_modint` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:11:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse static_modint::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `static_modint` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::static_modint` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `static_modint` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:471:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod static_modint {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    mod __pseudo_extern_prelude {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        pub(super) use crate::algebra;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m703\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m704\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::static_modint` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`algebra` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":6950,"byte_end":6957,"line_start":258,"line_end":258,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"    use algebra::*;","highlight_start":9,"highlight_end":16}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`algebra` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::algebra` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`algebra` could also refer to the module imported here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":6907,"byte_end":6939,"line_start":256,"line_end":256,"column_start":9,"column_end":41,"is_primary":true,"text":[{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":9,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::algebra` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `algebra` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:258:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use algebra::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `algebra` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::algebra` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `algebra` could also refer to the module imported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:256:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use self::__pseudo_extern_prelude::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::algebra` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`algebra` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":13336,"byte_end":13343,"line_start":478,"line_end":478,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"    use algebra::{One, Zero};","highlight_start":9,"highlight_end":16}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`algebra` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::algebra` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`algebra` could also refer to the module imported here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":13262,"byte_end":13294,"line_start":475,"line_end":475,"column_start":9,"column_end":41,"is_primary":true,"text":[{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":9,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::algebra` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `algebra` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:478:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use algebra::{One, Zero};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `algebra` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::algebra` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `algebra` could also refer to the module imported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:475:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use self::__pseudo_extern_prelude::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::algebra` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"aborting due to 6 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 6 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0659`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0659`.\u001b[0m\n"}
