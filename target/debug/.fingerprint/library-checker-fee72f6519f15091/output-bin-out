{"message":"`cuckoo_hashing` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":435,"byte_end":449,"line_start":8,"line_end":8,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use cuckoo_hashing::CuckooHashMap;","highlight_start":5,"highlight_end":19}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`cuckoo_hashing` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::cuckoo_hashing` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`cuckoo_hashing` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":1127,"byte_end":7774,"line_start":38,"line_end":216,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod cuckoo_hashing {","highlight_start":1,"highlight_end":25},{"text":"    mod __pseudo_extern_prelude {","highlight_start":1,"highlight_end":34},{"text":"        pub(super) use crate::__fxhash_0_1_0 as fxhash;","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    use fxhash::RandomState;","highlight_start":1,"highlight_end":29},{"text":"    use std::hash::{BuildHasher, Hash, Hasher};","highlight_start":1,"highlight_end":48},{"text":"    use std::mem::MaybeUninit;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    const REDUN: usize = 3;","highlight_start":1,"highlight_end":28},{"text":"    pub struct CuckooHashMap<K: Hash + Eq, V> {","highlight_start":1,"highlight_end":48},{"text":"        table: [Box<[Option<(K, V)>]>; REDUN],","highlight_start":1,"highlight_end":47},{"text":"        hash: [RandomState; REDUN],","highlight_start":1,"highlight_end":36},{"text":"        size: usize,","highlight_start":1,"highlight_end":21},{"text":"        len: usize,","highlight_start":1,"highlight_end":20},{"text":"        len_log: usize,","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<K: Hash + Eq, V> CuckooHashMap<K, V> {","highlight_start":1,"highlight_end":48},{"text":"        pub fn new() -> Self {","highlight_start":1,"highlight_end":31},{"text":"            let mut table: [MaybeUninit<Box<[Option<(K, V)>]>>; REDUN] =","highlight_start":1,"highlight_end":73},{"text":"                unsafe { MaybeUninit::uninit().assume_init() };","highlight_start":1,"highlight_end":64},{"text":"            let mut hash: [MaybeUninit<RandomState>; REDUN] =","highlight_start":1,"highlight_end":62},{"text":"                unsafe { MaybeUninit::uninit().assume_init() };","highlight_start":1,"highlight_end":64},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                let mut v = Vec::with_capacity(1);","highlight_start":1,"highlight_end":51},{"text":"                let array = unsafe {","highlight_start":1,"highlight_end":37},{"text":"                    v.set_len(1);","highlight_start":1,"highlight_end":34},{"text":"                    v.into_boxed_slice()","highlight_start":1,"highlight_end":41},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                table[i] = MaybeUninit::new(array);","highlight_start":1,"highlight_end":52},{"text":"                hash[i] = MaybeUninit::new(RandomState::new());","highlight_start":1,"highlight_end":64},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let table = unsafe { std::mem::transmute::<_, [Box<[Option<(K, V)>]>; REDUN]>(table) };","highlight_start":1,"highlight_end":100},{"text":"            let hash = unsafe { std::mem::transmute::<_, [RandomState; REDUN]>(hash) };","highlight_start":1,"highlight_end":88},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                table,","highlight_start":1,"highlight_end":23},{"text":"                hash,","highlight_start":1,"highlight_end":22},{"text":"                size: 0,","highlight_start":1,"highlight_end":25},{"text":"                len: 1,","highlight_start":1,"highlight_end":24},{"text":"                len_log: 0,","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn get(&self, k: &K) -> Option<&V> {","highlight_start":1,"highlight_end":49},{"text":"            let h = self.hash(k);","highlight_start":1,"highlight_end":34},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                if let Some((ref rk, ref v)) = self.table[i][h[i]] {","highlight_start":1,"highlight_end":69},{"text":"                    if rk == k {","highlight_start":1,"highlight_end":33},{"text":"                        return Some(v);","highlight_start":1,"highlight_end":40},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            None","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn insert(&mut self, mut k: K, mut v: V) -> Option<V> {","highlight_start":1,"highlight_end":68},{"text":"            self.size += 1;","highlight_start":1,"highlight_end":28},{"text":"            if !self.load_factor_is_ok() {","highlight_start":1,"highlight_end":43},{"text":"                self.double();","highlight_start":1,"highlight_end":31},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let h = self.hash(&k);","highlight_start":1,"highlight_end":35},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                if self.table[i][h[i]].is_none() {","highlight_start":1,"highlight_end":51},{"text":"                    self.table[i][h[i]] = Some((k, v));","highlight_start":1,"highlight_end":56},{"text":"                    return None;","highlight_start":1,"highlight_end":33},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if self.table[i][h[i]].as_ref().unwrap().0 == k {","highlight_start":1,"highlight_end":70},{"text":"                        let (_, v) = self.table[i][h[i]].replace((k, v)).unwrap();","highlight_start":1,"highlight_end":83},{"text":"                        return Some(v);","highlight_start":1,"highlight_end":40},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            loop {","highlight_start":1,"highlight_end":19},{"text":"                let mut j = 0;","highlight_start":1,"highlight_end":31},{"text":"                for _ in 0..self.len_log + 2 {","highlight_start":1,"highlight_end":47},{"text":"                    let h = self.hash_one(&k, j);","highlight_start":1,"highlight_end":50},{"text":"                    if self.table[j][h].is_none() {","highlight_start":1,"highlight_end":52},{"text":"                        self.table[j][h] = Some((k, v));","highlight_start":1,"highlight_end":57},{"text":"                        return None;","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        let kv = self.table[j][h].replace((k, v)).unwrap();","highlight_start":1,"highlight_end":76},{"text":"                        if self.table[j][h].as_ref().unwrap().0 == kv.0 {","highlight_start":1,"highlight_end":74},{"text":"                            return Some(kv.1);","highlight_start":1,"highlight_end":47},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        k = kv.0;","highlight_start":1,"highlight_end":34},{"text":"                        v = kv.1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    j += 1;","highlight_start":1,"highlight_end":28},{"text":"                    if j >= REDUN {","highlight_start":1,"highlight_end":36},{"text":"                        j -= REDUN;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                self.rehash();","highlight_start":1,"highlight_end":31},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn remove(&mut self, k: &K) -> Option<V> {","highlight_start":1,"highlight_end":55},{"text":"            let h = self.hash(k);","highlight_start":1,"highlight_end":34},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                if self.table[i][h[i]].is_some() {","highlight_start":1,"highlight_end":51},{"text":"                    if self.table[i][h[i]].as_ref().unwrap().0 == *k {","highlight_start":1,"highlight_end":71},{"text":"                        let (_, v) = self.table[i][h[i]].take().unwrap();","highlight_start":1,"highlight_end":74},{"text":"                        self.size -= 1;","highlight_start":1,"highlight_end":40},{"text":"                        if self.size * 4 < self.len * REDUN {","highlight_start":1,"highlight_end":62},{"text":"                            // if load factor is less than 0.25","highlight_start":1,"highlight_end":64},{"text":"                            self.half();","highlight_start":1,"highlight_end":41},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        return Some(v);","highlight_start":1,"highlight_end":40},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            None","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        #[inline(always)]","highlight_start":1,"highlight_end":26},{"text":"        fn load_factor_is_ok(&self) -> bool {","highlight_start":1,"highlight_end":46},{"text":"            // 50% is threshold","highlight_start":1,"highlight_end":32},{"text":"            self.size * 2 <= self.len * REDUN","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn rehash(&mut self) {","highlight_start":1,"highlight_end":31},{"text":"            let mut hash: [MaybeUninit<RandomState>; REDUN] =","highlight_start":1,"highlight_end":62},{"text":"                unsafe { MaybeUninit::uninit().assume_init() };","highlight_start":1,"highlight_end":64},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                hash[i] = MaybeUninit::new(RandomState::new());","highlight_start":1,"highlight_end":64},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let hash = unsafe { std::mem::transmute::<_, [RandomState; REDUN]>(hash) };","highlight_start":1,"highlight_end":88},{"text":"            self.hash = hash;","highlight_start":1,"highlight_end":30},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                for j in 0..self.len {","highlight_start":1,"highlight_end":39},{"text":"                    if let Some((k, v)) = self.table[i][j].take() {","highlight_start":1,"highlight_end":68},{"text":"                        self.insert(k, v);","highlight_start":1,"highlight_end":43},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        #[inline(always)]","highlight_start":1,"highlight_end":26},{"text":"        fn double(&mut self) {","highlight_start":1,"highlight_end":31},{"text":"            self.resize(self.len_log + 1, self.len << 1);","highlight_start":1,"highlight_end":58},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        #[inline(always)]","highlight_start":1,"highlight_end":26},{"text":"        fn half(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"            self.resize(self.len_log - 1, self.len >> 1);","highlight_start":1,"highlight_end":58},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn resize(&mut self, new_len_log: usize, new_len: usize) {","highlight_start":1,"highlight_end":67},{"text":"            let mut table: [MaybeUninit<Box<[Option<(K, V)>]>>; REDUN] =","highlight_start":1,"highlight_end":73},{"text":"                unsafe { MaybeUninit::uninit().assume_init() };","highlight_start":1,"highlight_end":64},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                let mut v = Vec::with_capacity(new_len);","highlight_start":1,"highlight_end":57},{"text":"                let array = unsafe {","highlight_start":1,"highlight_end":37},{"text":"                    v.set_len(new_len);","highlight_start":1,"highlight_end":40},{"text":"                    v.into_boxed_slice()","highlight_start":1,"highlight_end":41},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                table[i] = MaybeUninit::new(array);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let table = unsafe { std::mem::transmute::<_, [Box<[Option<(K, V)>]>; REDUN]>(table) };","highlight_start":1,"highlight_end":100},{"text":"            let mut table = std::mem::replace(&mut self.table, table);","highlight_start":1,"highlight_end":71},{"text":"            let old_len = std::mem::replace(&mut self.len, new_len);","highlight_start":1,"highlight_end":69},{"text":"            self.len_log = new_len_log;","highlight_start":1,"highlight_end":40},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                for j in 0..old_len {","highlight_start":1,"highlight_end":38},{"text":"                    if let Some((k, v)) = table[i][j].take() {","highlight_start":1,"highlight_end":63},{"text":"                        self.insert(k, v);","highlight_start":1,"highlight_end":43},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn hash(&self, k: &K) -> [usize; REDUN] {","highlight_start":1,"highlight_end":50},{"text":"            let mut ret = [0; REDUN];","highlight_start":1,"highlight_end":38},{"text":"            for i in 0..REDUN {","highlight_start":1,"highlight_end":32},{"text":"                let mut hasher = self.hash[i].build_hasher();","highlight_start":1,"highlight_end":62},{"text":"                k.hash(&mut hasher);","highlight_start":1,"highlight_end":37},{"text":"                ret[i] = hasher.finish() as usize & (self.len - 1);","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ret","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn hash_one(&self, k: &K, idx: usize) -> usize {","highlight_start":1,"highlight_end":57},{"text":"            let mut hasher = self.hash[idx].build_hasher();","highlight_start":1,"highlight_end":60},{"text":"            k.hash(&mut hasher);","highlight_start":1,"highlight_end":33},{"text":"            hasher.finish() as usize & (self.len - 1)","highlight_start":1,"highlight_end":54},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::cuckoo_hashing` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `cuckoo_hashing` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:8:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse cuckoo_hashing::CuckooHashMap;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `cuckoo_hashing` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::cuckoo_hashing` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `cuckoo_hashing` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:38:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod cuckoo_hashing {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    mod __pseudo_extern_prelude {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        pub(super) use crate::__fxhash_0_1_0 as fxhash;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::cuckoo_hashing` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`scanner` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":470,"byte_end":477,"line_start":9,"line_end":9,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use scanner::*;","highlight_start":5,"highlight_end":12}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`scanner` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::scanner` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`scanner` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":10410,"byte_end":12959,"line_start":321,"line_end":409,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod scanner {","highlight_start":1,"highlight_end":18},{"text":"    pub use crate::scan;","highlight_start":1,"highlight_end":25},{"text":"    use std::io::BufRead;","highlight_start":1,"highlight_end":26},{"text":"    use std::str::{FromStr, SplitWhitespace};","highlight_start":1,"highlight_end":46},{"text":"    use std::thread_local;","highlight_start":1,"highlight_end":27},{"text":"    use std::{cell::RefCell, io};","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Readable {","highlight_start":1,"highlight_end":25},{"text":"        type Output;","highlight_start":1,"highlight_end":21},{"text":"        fn read(input: &str) -> Self::Output;","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: FromStr> Readable for T {","highlight_start":1,"highlight_end":38},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse().ok().unwrap()","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    struct Tokenizer<T: BufRead> {","highlight_start":1,"highlight_end":35},{"text":"        source: T,","highlight_start":1,"highlight_end":19},{"text":"        token: SplitWhitespace<'static>,","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Tokenizer<T> {","highlight_start":1,"highlight_end":36},{"text":"        fn read(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"            self.source","highlight_start":1,"highlight_end":24},{"text":"                .read_line(&mut line)","highlight_start":1,"highlight_end":38},{"text":"                .expect(\"an IO error occured\");","highlight_start":1,"highlight_end":48},{"text":"            self.token = Box::leak(line.into_boxed_str()).split_whitespace();","highlight_start":1,"highlight_end":78},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn next(&mut self) -> &str {","highlight_start":1,"highlight_end":37},{"text":"            if let Some(x) = self.token.next() {","highlight_start":1,"highlight_end":49},{"text":"                x","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                self.read();","highlight_start":1,"highlight_end":29},{"text":"                self.next()","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub struct Scanner<T: BufRead> {","highlight_start":1,"highlight_end":37},{"text":"        tokenizer: Tokenizer<T>,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Scanner<T> {","highlight_start":1,"highlight_end":34},{"text":"        pub fn new(source: T) -> Self {","highlight_start":1,"highlight_end":40},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                tokenizer: Tokenizer {","highlight_start":1,"highlight_end":39},{"text":"                    source,","highlight_start":1,"highlight_end":28},{"text":"                    token: \"\".split_whitespace(),","highlight_start":1,"highlight_end":50},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn scan<U: Readable>(&mut self) -> U::Output {","highlight_start":1,"highlight_end":59},{"text":"            U::read(self.tokenizer.next())","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    thread_local! (","highlight_start":1,"highlight_end":20},{"text":"        pub static STDIN: RefCell<Scanner<std::io::StdinLock<'static>>> = {","highlight_start":1,"highlight_end":76},{"text":"            let stdin = Box::leak(Box::new(io::stdin()));","highlight_start":1,"highlight_end":58},{"text":"            RefCell::new(Scanner::new(stdin.lock()))","highlight_start":1,"highlight_end":53},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! scan {","highlight_start":1,"highlight_end":24},{"text":"        ([char]) => {","highlight_start":1,"highlight_end":22},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().chars().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([u8]) => {","highlight_start":1,"highlight_end":20},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().bytes().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([$($t:tt),*; $n:expr]) => {","highlight_start":1,"highlight_end":37},{"text":"            (0..$n).map(|_| ($(scan!($t)),*)).collect::<Vec<_>>()","highlight_start":1,"highlight_end":66},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($t:ty) => {","highlight_start":1,"highlight_end":21},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<$t>())","highlight_start":1,"highlight_end":64},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            ($(scan!($t)),*)","highlight_start":1,"highlight_end":29},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(non_camel_case_types)]","highlight_start":1,"highlight_end":35},{"text":"    pub struct usize1();","highlight_start":1,"highlight_end":25},{"text":"    impl Readable for usize1 {","highlight_start":1,"highlight_end":31},{"text":"        type Output = usize;","highlight_start":1,"highlight_end":29},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse::<usize>().unwrap() - 1","highlight_start":1,"highlight_end":48},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::scanner` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `scanner` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:9:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse scanner::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `scanner` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::scanner` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `scanner` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:321:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m321\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod scanner {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::scan;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io::BufRead;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::str::{FromStr, SplitWhitespace};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m408\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::scanner` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`fxhash` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":1299,"byte_end":1305,"line_start":44,"line_end":44,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"    use fxhash::RandomState;","highlight_start":9,"highlight_end":15}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`fxhash` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::fxhash` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`fxhash` could also refer to the module imported here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":1256,"byte_end":1288,"line_start":42,"line_end":42,"column_start":9,"column_end":41,"is_primary":true,"text":[{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":9,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::fxhash` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `fxhash` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:44:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use fxhash::RandomState;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `fxhash` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::fxhash` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `fxhash` could also refer to the module imported here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:42:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use self::__pseudo_extern_prelude::*;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::fxhash` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`xorshift` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":8068,"byte_end":8076,"line_start":228,"line_end":228,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use xorshift::xorshift64;","highlight_start":9,"highlight_end":17}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`xorshift` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::xorshift` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`xorshift` could also refer to the module imported here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":7926,"byte_end":7958,"line_start":223,"line_end":223,"column_start":9,"column_end":41,"is_primary":true,"text":[{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":9,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::xorshift` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `xorshift` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:228:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use xorshift::xorshift64;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `xorshift` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::xorshift` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `xorshift` could also refer to the module imported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:223:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    use self::__pseudo_extern_prelude::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::xorshift` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0659`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0659`.\u001b[0m\n"}
