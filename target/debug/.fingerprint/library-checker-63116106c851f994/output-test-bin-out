{"message":"`binary_trie` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":227,"byte_end":238,"line_start":6,"line_end":6,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"use binary_trie::*;","highlight_start":5,"highlight_end":16}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`binary_trie` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::binary_trie` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`binary_trie` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":877,"byte_end":6814,"line_start":34,"line_end":222,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod binary_trie {","highlight_start":1,"highlight_end":22},{"text":"    struct Node {","highlight_start":1,"highlight_end":18},{"text":"        size: usize,","highlight_start":1,"highlight_end":21},{"text":"        child: [Tree; 2],","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl Node {","highlight_start":1,"highlight_end":16},{"text":"        fn none() -> Self {","highlight_start":1,"highlight_end":28},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                size: 0,","highlight_start":1,"highlight_end":25},{"text":"                child: [Tree::none(), Tree::none()],","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    struct Tree(Option<Box<Node>>);","highlight_start":1,"highlight_end":36},{"text":"    impl Tree {","highlight_start":1,"highlight_end":16},{"text":"        fn none() -> Self {","highlight_start":1,"highlight_end":28},{"text":"            Tree(None)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn new(val: Node) -> Self {","highlight_start":1,"highlight_end":36},{"text":"            Tree(Some(Box::new(val)))","highlight_start":1,"highlight_end":38},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn is_none(&self) -> bool {","highlight_start":1,"highlight_end":36},{"text":"            self.0.is_none()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn is_some(&self) -> bool {","highlight_start":1,"highlight_end":36},{"text":"            self.0.is_some()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn size(&self) -> usize {","highlight_start":1,"highlight_end":34},{"text":"            if let Some(x) = self.0.as_ref() {","highlight_start":1,"highlight_end":47},{"text":"                x.size","highlight_start":1,"highlight_end":23},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn insert(&mut self, val: u64, bit: i32) {","highlight_start":1,"highlight_end":51},{"text":"            // 下からbit目のところです。","highlight_start":1,"highlight_end":30},{"text":"            if self.is_none() {","highlight_start":1,"highlight_end":32},{"text":"                *self = Tree::new(Node::none());","highlight_start":1,"highlight_end":49},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let node = self.0.as_mut().unwrap();","highlight_start":1,"highlight_end":49},{"text":"            node.size += 1;","highlight_start":1,"highlight_end":28},{"text":"            if bit >= 0 {","highlight_start":1,"highlight_end":26},{"text":"                let f = (val >> bit) & 1;","highlight_start":1,"highlight_end":42},{"text":"                node.child[f as usize].insert(val, bit - 1);","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn remove(&mut self, val: u64, bit: i32) {","highlight_start":1,"highlight_end":51},{"text":"            assert!(self.is_some());","highlight_start":1,"highlight_end":37},{"text":"            let node = self.0.as_mut().unwrap();","highlight_start":1,"highlight_end":49},{"text":"            node.size -= 1;","highlight_start":1,"highlight_end":28},{"text":"            if node.size == 0 {","highlight_start":1,"highlight_end":32},{"text":"                *self = Tree::none();","highlight_start":1,"highlight_end":38},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            if bit >= 0 {","highlight_start":1,"highlight_end":26},{"text":"                let f = (val >> bit) & 1;","highlight_start":1,"highlight_end":42},{"text":"                node.child[f as usize].remove(val, bit - 1);","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn min(&self, bit: i32, bias: u64) -> u64 {","highlight_start":1,"highlight_end":52},{"text":"            //! min in ^bias","highlight_start":1,"highlight_end":29},{"text":"            assert!(self.is_some());","highlight_start":1,"highlight_end":37},{"text":"            let node = self.0.as_ref().unwrap();","highlight_start":1,"highlight_end":49},{"text":"            if bit < 0 {","highlight_start":1,"highlight_end":25},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                let f = (bias >> bit) & 1;","highlight_start":1,"highlight_end":43},{"text":"                if f == 0 {","highlight_start":1,"highlight_end":28},{"text":"                    if node.child[0].is_some() {","highlight_start":1,"highlight_end":49},{"text":"                        node.child[0].min(bit - 1, bias)","highlight_start":1,"highlight_end":57},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        node.child[1].min(bit - 1, bias) | (1 << bit)","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if node.child[1].is_some() {","highlight_start":1,"highlight_end":49},{"text":"                        node.child[1].min(bit - 1, bias) | (1 << bit)","highlight_start":1,"highlight_end":70},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        node.child[0].min(bit - 1, bias)","highlight_start":1,"highlight_end":57},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn max(&self, bit: i32, bias: u64) -> u64 {","highlight_start":1,"highlight_end":52},{"text":"            assert!(self.is_some());","highlight_start":1,"highlight_end":37},{"text":"            let node = self.0.as_ref().unwrap();","highlight_start":1,"highlight_end":49},{"text":"            if bit < 0 {","highlight_start":1,"highlight_end":25},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                let f = (bias >> bit) & 1;","highlight_start":1,"highlight_end":43},{"text":"                if f == 0 {","highlight_start":1,"highlight_end":28},{"text":"                    if node.child[1].is_some() {","highlight_start":1,"highlight_end":49},{"text":"                        node.child[1].min(bit - 1, bias) | (1 << bit)","highlight_start":1,"highlight_end":70},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        node.child[0].min(bit - 1, bias)","highlight_start":1,"highlight_end":57},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if node.child[0].is_some() {","highlight_start":1,"highlight_end":49},{"text":"                        node.child[0].min(bit - 1, bias)","highlight_start":1,"highlight_end":57},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        node.child[1].min(bit - 1, bias) | (1 << bit)","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn kth(&self, k: usize, bit: i32) -> u64 {","highlight_start":1,"highlight_end":51},{"text":"            //! k is 0-indexed.","highlight_start":1,"highlight_end":32},{"text":"            assert!(self.is_some());","highlight_start":1,"highlight_end":37},{"text":"            let node = self.0.as_ref().unwrap();","highlight_start":1,"highlight_end":49},{"text":"            if bit < 0 {","highlight_start":1,"highlight_end":25},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                let m = node.child[0].size();","highlight_start":1,"highlight_end":46},{"text":"                if k < m {","highlight_start":1,"highlight_end":27},{"text":"                    node.child[0].kth(k, bit - 1)","highlight_start":1,"highlight_end":50},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    node.child[1].kth(k - m, bit - 1) | (1 << bit)","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn count_lower(&self, val: u64, bit: i32) -> usize {","highlight_start":1,"highlight_end":61},{"text":"            //! count elements s.t. < val","highlight_start":1,"highlight_end":42},{"text":"            if self.is_some() || bit < 0 {","highlight_start":1,"highlight_end":43},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                let node = self.0.as_ref().unwrap();","highlight_start":1,"highlight_end":53},{"text":"                let f = (val >> bit) & 1;","highlight_start":1,"highlight_end":42},{"text":"                node.child[f as usize].count_lower(val, bit - 1)","highlight_start":1,"highlight_end":65},{"text":"                    + if f == 1 { node.child[0].size() } else { 0 }","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn count(&self, val: u64, bit: i32) -> usize {","highlight_start":1,"highlight_end":55},{"text":"            if bit < 0 {","highlight_start":1,"highlight_end":25},{"text":"                self.size()","highlight_start":1,"highlight_end":28},{"text":"            } else if self.is_none() {","highlight_start":1,"highlight_end":39},{"text":"                0","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                let node = self.0.as_ref().unwrap();","highlight_start":1,"highlight_end":53},{"text":"                let f = (val >> bit) & 1;","highlight_start":1,"highlight_end":42},{"text":"                node.child[f as usize].count(val, bit - 1)","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub struct BinaryTrie {","highlight_start":1,"highlight_end":28},{"text":"        root: Tree,","highlight_start":1,"highlight_end":20},{"text":"        bitlen: i32,","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl BinaryTrie {","highlight_start":1,"highlight_end":22},{"text":"        pub fn new(bitlen: i32) -> Self {","highlight_start":1,"highlight_end":42},{"text":"            BinaryTrie {","highlight_start":1,"highlight_end":25},{"text":"                root: Tree::none(),","highlight_start":1,"highlight_end":36},{"text":"                bitlen,","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn size(&self) -> usize {","highlight_start":1,"highlight_end":38},{"text":"            self.root.size()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn insert(&mut self, val: u64) {","highlight_start":1,"highlight_end":45},{"text":"            self.root.insert(val, self.bitlen - 1);","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn remove(&mut self, val: u64) {","highlight_start":1,"highlight_end":45},{"text":"            self.root.remove(val, self.bitlen - 1);","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn max(&self) -> u64 {","highlight_start":1,"highlight_end":35},{"text":"            self.root.max(self.bitlen - 1, 0)","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn min(&self) -> u64 {","highlight_start":1,"highlight_end":35},{"text":"            self.root.min(self.bitlen - 1, 0)","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn max_xor(&self, x: u64) -> u64 {","highlight_start":1,"highlight_end":47},{"text":"            self.root.max(self.bitlen - 1, x)","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn min_xor(&self, x: u64) -> u64 {","highlight_start":1,"highlight_end":47},{"text":"            self.root.min(self.bitlen - 1, x)","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn lower_bound(&self, val: u64) -> usize {","highlight_start":1,"highlight_end":55},{"text":"            self.root.count_lower(val, self.bitlen - 1)","highlight_start":1,"highlight_end":56},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn upper_bound(&self, val: u64) -> usize {","highlight_start":1,"highlight_end":55},{"text":"            self.root.count_lower(val + 1, self.bitlen - 1)","highlight_start":1,"highlight_end":60},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn kth(&self, k: usize) -> u64 {","highlight_start":1,"highlight_end":45},{"text":"            self.root.kth(k, self.bitlen - 1)","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn count(&self, val: u64) -> usize {","highlight_start":1,"highlight_end":49},{"text":"            self.root.count(val, self.bitlen - 1)","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::binary_trie` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `binary_trie` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:6:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse binary_trie::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `binary_trie` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::binary_trie` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `binary_trie` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:34:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod binary_trie {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    struct Node {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        size: usize,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        child: [Tree; 2],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::binary_trie` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`scanner` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":247,"byte_end":254,"line_start":7,"line_end":7,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use scanner::*;","highlight_start":5,"highlight_end":12}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`scanner` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::scanner` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`scanner` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/out.rs","byte_start":6833,"byte_end":9382,"line_start":225,"line_end":313,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod scanner {","highlight_start":1,"highlight_end":18},{"text":"    pub use crate::scan;","highlight_start":1,"highlight_end":25},{"text":"    use std::io::BufRead;","highlight_start":1,"highlight_end":26},{"text":"    use std::str::{FromStr, SplitWhitespace};","highlight_start":1,"highlight_end":46},{"text":"    use std::thread_local;","highlight_start":1,"highlight_end":27},{"text":"    use std::{cell::RefCell, io};","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub trait Readable {","highlight_start":1,"highlight_end":25},{"text":"        type Output;","highlight_start":1,"highlight_end":21},{"text":"        fn read(input: &str) -> Self::Output;","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: FromStr> Readable for T {","highlight_start":1,"highlight_end":38},{"text":"        type Output = Self;","highlight_start":1,"highlight_end":28},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse().ok().unwrap()","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    struct Tokenizer<T: BufRead> {","highlight_start":1,"highlight_end":35},{"text":"        source: T,","highlight_start":1,"highlight_end":19},{"text":"        token: SplitWhitespace<'static>,","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Tokenizer<T> {","highlight_start":1,"highlight_end":36},{"text":"        fn read(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"            self.source","highlight_start":1,"highlight_end":24},{"text":"                .read_line(&mut line)","highlight_start":1,"highlight_end":38},{"text":"                .expect(\"an IO error occured\");","highlight_start":1,"highlight_end":48},{"text":"            self.token = Box::leak(line.into_boxed_str()).split_whitespace();","highlight_start":1,"highlight_end":78},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn next(&mut self) -> &str {","highlight_start":1,"highlight_end":37},{"text":"            if let Some(x) = self.token.next() {","highlight_start":1,"highlight_end":49},{"text":"                x","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                self.read();","highlight_start":1,"highlight_end":29},{"text":"                self.next()","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub struct Scanner<T: BufRead> {","highlight_start":1,"highlight_end":37},{"text":"        tokenizer: Tokenizer<T>,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Scanner<T> {","highlight_start":1,"highlight_end":34},{"text":"        pub fn new(source: T) -> Self {","highlight_start":1,"highlight_end":40},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                tokenizer: Tokenizer {","highlight_start":1,"highlight_end":39},{"text":"                    source,","highlight_start":1,"highlight_end":28},{"text":"                    token: \"\".split_whitespace(),","highlight_start":1,"highlight_end":50},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn scan<U: Readable>(&mut self) -> U::Output {","highlight_start":1,"highlight_end":59},{"text":"            U::read(self.tokenizer.next())","highlight_start":1,"highlight_end":43},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    thread_local! (","highlight_start":1,"highlight_end":20},{"text":"        pub static STDIN: RefCell<Scanner<std::io::StdinLock<'static>>> = {","highlight_start":1,"highlight_end":76},{"text":"            let stdin = Box::leak(Box::new(io::stdin()));","highlight_start":1,"highlight_end":58},{"text":"            RefCell::new(Scanner::new(stdin.lock()))","highlight_start":1,"highlight_end":53},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! scan {","highlight_start":1,"highlight_end":24},{"text":"        ([char]) => {","highlight_start":1,"highlight_end":22},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().chars().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([u8]) => {","highlight_start":1,"highlight_end":20},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<String>().bytes().collect::<Vec<_>>())","highlight_start":1,"highlight_end":96},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ([$($t:tt),*; $n:expr]) => {","highlight_start":1,"highlight_end":37},{"text":"            (0..$n).map(|_| ($(scan!($t)),*)).collect::<Vec<_>>()","highlight_start":1,"highlight_end":66},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($t:ty) => {","highlight_start":1,"highlight_end":21},{"text":"            STDIN.with(|stdin| stdin.borrow_mut().scan::<$t>())","highlight_start":1,"highlight_end":64},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($($t:ty),+) => {","highlight_start":1,"highlight_end":26},{"text":"            ($(scan!($t)),*)","highlight_start":1,"highlight_end":29},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(non_camel_case_types)]","highlight_start":1,"highlight_end":35},{"text":"    pub struct usize1();","highlight_start":1,"highlight_end":25},{"text":"    impl Readable for usize1 {","highlight_start":1,"highlight_end":31},{"text":"        type Output = usize;","highlight_start":1,"highlight_end":29},{"text":"        fn read(input: &str) -> Self::Output {","highlight_start":1,"highlight_end":47},{"text":"            input.parse::<usize>().unwrap() - 1","highlight_start":1,"highlight_end":48},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::scanner` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `scanner` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:7:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse scanner::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `scanner` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::scanner` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `scanner` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/out.rs:225:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod scanner {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::scan;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io::BufRead;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::str::{FromStr, SplitWhitespace};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m313\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::scanner` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0659`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0659`.\u001b[0m\n"}
