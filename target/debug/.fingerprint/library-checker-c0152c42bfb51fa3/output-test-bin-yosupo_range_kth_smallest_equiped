{"message":"`scanner` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":390,"byte_end":397,"line_start":10,"line_end":10,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use scanner::*;","highlight_start":5,"highlight_end":12}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`scanner` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::scanner` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`scanner` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":4627,"byte_end":6865,"line_start":146,"line_end":220,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod scanner {","highlight_start":1,"highlight_end":18},{"text":"    pub use crate::scan;","highlight_start":1,"highlight_end":25},{"text":"    use std::io;","highlight_start":1,"highlight_end":17},{"text":"    use std::io::BufRead;","highlight_start":1,"highlight_end":26},{"text":"    use std::str::{FromStr, SplitWhitespace};","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    struct Tokenizer<T: BufRead> {","highlight_start":1,"highlight_end":35},{"text":"        source: T,","highlight_start":1,"highlight_end":19},{"text":"        token: SplitWhitespace<'static>,","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Tokenizer<T> {","highlight_start":1,"highlight_end":36},{"text":"        fn new(source: T) -> Self {","highlight_start":1,"highlight_end":36},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                source,","highlight_start":1,"highlight_end":24},{"text":"                token: \"\".split_whitespace(),","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn read(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"            self.source","highlight_start":1,"highlight_end":24},{"text":"                .read_line(&mut line)","highlight_start":1,"highlight_end":38},{"text":"                .expect(\"Failed to get a line. Maybe an IO error occured\");","highlight_start":1,"highlight_end":76},{"text":"            let buf: &'static str = Box::leak(line.into_boxed_str());","highlight_start":1,"highlight_end":70},{"text":"            self.token = buf.split_whitespace();","highlight_start":1,"highlight_end":49},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        fn next(&mut self) -> Option<&str> {","highlight_start":1,"highlight_end":45},{"text":"            if let Some(x) = self.token.next() {","highlight_start":1,"highlight_end":49},{"text":"                Some(x)","highlight_start":1,"highlight_end":24},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                self.read();","highlight_start":1,"highlight_end":29},{"text":"                self.next()","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub struct Scanner<T: BufRead> {","highlight_start":1,"highlight_end":37},{"text":"        tokenizer: Tokenizer<T>,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl<T: BufRead> Scanner<T> {","highlight_start":1,"highlight_end":34},{"text":"        pub fn new(source: T) -> Self {","highlight_start":1,"highlight_end":40},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                tokenizer: Tokenizer::new(source),","highlight_start":1,"highlight_end":51},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn scan<U: FromStr>(&mut self) -> U {","highlight_start":1,"highlight_end":50},{"text":"            self.tokenizer.next().unwrap().parse::<U>().ok().unwrap()","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    impl Scanner<io::StdinLock<'static>> {","highlight_start":1,"highlight_end":43},{"text":"        pub fn new_stdin() -> Self {","highlight_start":1,"highlight_end":37},{"text":"            let stdin = Box::leak(Box::new(io::stdin()));","highlight_start":1,"highlight_end":58},{"text":"            Scanner::new(stdin.lock())","highlight_start":1,"highlight_end":39},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[macro_export]","highlight_start":1,"highlight_end":20},{"text":"    macro_rules! scan {","highlight_start":1,"highlight_end":24},{"text":"        ($scanner:ident; [char]) => {","highlight_start":1,"highlight_end":38},{"text":"            $scanner.scan::<String>().chars().collect::<Vec<_>>()","highlight_start":1,"highlight_end":66},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($scanner:ident; [u8]) => {","highlight_start":1,"highlight_end":36},{"text":"            $scanner.scan::<String>().bytes().collect::<Vec<_>>()","highlight_start":1,"highlight_end":66},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($scanner:ident; [$($t:tt),+; $n:expr]) => {","highlight_start":1,"highlight_end":53},{"text":"            (0..$n).map(|_| ($(scan!($scanner;$t)),*)).collect::<Vec<_>>()","highlight_start":1,"highlight_end":75},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($scanner:ident; usize1) => {","highlight_start":1,"highlight_end":38},{"text":"            $scanner.scan::<usize>() - 1","highlight_start":1,"highlight_end":41},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($scanner:ident; $t:ty) => {","highlight_start":1,"highlight_end":37},{"text":"            $scanner.scan::<$t>()","highlight_start":1,"highlight_end":34},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        ($scanner:ident; $($t:tt),+) => {","highlight_start":1,"highlight_end":42},{"text":"            ($(scan!($scanner; $t)),*)","highlight_start":1,"highlight_end":39},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::scanner` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `scanner` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs:10:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse scanner::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `scanner` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::scanner` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `scanner` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs:146:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod scanner {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub use crate::scan;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::io::BufRead;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m220\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::scanner` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"`wavelet_matrix` is ambiguous (name vs any other name during import resolution)","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":406,"byte_end":420,"line_start":11,"line_end":11,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use wavelet_matrix::WaveletMatrix;","highlight_start":5,"highlight_end":19}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`wavelet_matrix` could refer to a crate passed with `--extern`","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `::wavelet_matrix` to refer to this crate unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`wavelet_matrix` could also refer to the module defined here","code":null,"level":"note","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":6884,"byte_end":12154,"line_start":223,"line_end":350,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub mod wavelet_matrix {","highlight_start":1,"highlight_end":25},{"text":"    mod __pseudo_extern_prelude {","highlight_start":1,"highlight_end":34},{"text":"        pub(super) use crate::__bit_vector_0_1_0 as bit_vector;","highlight_start":1,"highlight_end":64},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    use self::__pseudo_extern_prelude::*;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    use bit_vector::{access, BitVector};","highlight_start":1,"highlight_end":41},{"text":"    use std::ops::Range;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// WaveletMatrix です。","highlight_start":1,"highlight_end":26},{"text":"    /// u64が入りますが、圧縮した方が良い気がします。","highlight_start":1,"highlight_end":33},{"text":"    #[derive(Debug)]","highlight_start":1,"highlight_end":21},{"text":"    pub struct WaveletMatrix {","highlight_start":1,"highlight_end":31},{"text":"        /// Box<[(0の個数、ビット列)]です。","highlight_start":1,"highlight_end":33},{"text":"        /// 上位bitから入っています。気をつけましょう。","highlight_start":1,"highlight_end":36},{"text":"        data: Box<[(usize, BitVector)]>,","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    impl WaveletMatrix {","highlight_start":1,"highlight_end":25},{"text":"        pub fn new(bitlen: usize, mut seq: Vec<u64>) -> Self {","highlight_start":1,"highlight_end":63},{"text":"            //! bitlen: ceil(log2|alphabet|)ですね、つまり扱う対象が何bitで区別できるかです。","highlight_start":1,"highlight_end":71},{"text":"            //! set: 元データです。u64をください。","highlight_start":1,"highlight_end":38},{"text":"            let len = seq.len();","highlight_start":1,"highlight_end":33},{"text":"            let mut data = Vec::with_capacity(bitlen);","highlight_start":1,"highlight_end":55},{"text":"            for l in (0..bitlen).rev() {","highlight_start":1,"highlight_end":41},{"text":"                // 上位bitからですからね。","highlight_start":1,"highlight_end":33},{"text":"                let bv = seq.iter().map(|&x| access(x, l)).collect::<BitVector>();","highlight_start":1,"highlight_end":83},{"text":"                data.push((bv.rank0(len), bv));","highlight_start":1,"highlight_end":48},{"text":"                let zeros = seq.iter().filter(|&&x| !access(x, l)).cloned();","highlight_start":1,"highlight_end":77},{"text":"                let ones = seq.iter().filter(|&&x| access(x, l)).cloned();","highlight_start":1,"highlight_end":75},{"text":"                seq = zeros.chain(ones).collect();","highlight_start":1,"highlight_end":51},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Self {","highlight_start":1,"highlight_end":19},{"text":"                data: data.into_boxed_slice(),","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn access(&self, mut idx: usize) -> u64 {","highlight_start":1,"highlight_end":54},{"text":"            let mut ret: u64 = 0;","highlight_start":1,"highlight_end":34},{"text":"            for (l, &(zero, ref bv)) in (0..self.data.len()).rev().zip(self.data.iter()) {","highlight_start":1,"highlight_end":91},{"text":"                if !bv.access(idx) {","highlight_start":1,"highlight_end":37},{"text":"                    idx = bv.rank0(idx);","highlight_start":1,"highlight_end":41},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    ret |= 1 << l;","highlight_start":1,"highlight_end":35},{"text":"                    idx = zero + bv.rank1(idx);","highlight_start":1,"highlight_end":48},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ret","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub fn rank(&self, value: u64, mut range: Range<usize>) -> usize {","highlight_start":1,"highlight_end":75},{"text":"            for (l, &(zero, ref bv)) in (0..self.data.len()).rev().zip(self.data.iter()) {","highlight_start":1,"highlight_end":91},{"text":"                if !access(value, l) {","highlight_start":1,"highlight_end":39},{"text":"                    range.start = bv.rank0(range.start);","highlight_start":1,"highlight_end":57},{"text":"                    range.end = bv.rank0(range.end);","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    range.start = zero + bv.rank1(range.start);","highlight_start":1,"highlight_end":64},{"text":"                    range.end = zero + bv.rank1(range.end);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            range.end - range.start","highlight_start":1,"highlight_end":36},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub fn select(&self, value: u64, k: usize) -> usize {","highlight_start":1,"highlight_end":62},{"text":"            //! Return: the index of k-th value","highlight_start":1,"highlight_end":48},{"text":"            // まず一番下(整列されたやつ)で、valueが一番最初に現れるのがどこか調べる","highlight_start":1,"highlight_end":54},{"text":"            // rankとだいたい同じ","highlight_start":1,"highlight_end":27},{"text":"            let mut idx = 0;","highlight_start":1,"highlight_end":29},{"text":"            for (l, &(zero, ref bv)) in (0..self.data.len()).rev().zip(self.data.iter()) {","highlight_start":1,"highlight_end":91},{"text":"                if !access(value, l) {","highlight_start":1,"highlight_end":39},{"text":"                    idx = bv.rank0(idx);","highlight_start":1,"highlight_end":41},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    idx = zero + bv.rank1(idx);","highlight_start":1,"highlight_end":48},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            idx += k;","highlight_start":1,"highlight_end":22},{"text":"            // ここから戻ってくる","highlight_start":1,"highlight_end":25},{"text":"            for &(zero, ref bv) in self.data.iter().rev() {","highlight_start":1,"highlight_end":60},{"text":"                // valueのbitで場合分けなのですが、場所が分かっているので、zeroとの比較でよいです。","highlight_start":1,"highlight_end":66},{"text":"                if idx < zero {","highlight_start":1,"highlight_end":32},{"text":"                    idx = bv.select0(idx);","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    idx = bv.select1(idx - zero);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            idx","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub fn quantile(&self, mut range: Range<usize>, mut k: usize) -> u64 {","highlight_start":1,"highlight_end":79},{"text":"            //! Return: k-th min value in range","highlight_start":1,"highlight_end":48},{"text":"            //! Attention: k is 0-indexed.","highlight_start":1,"highlight_end":43},{"text":"            let mut ret = 0;","highlight_start":1,"highlight_end":29},{"text":"            for (l, &(zero, ref bv)) in (0..self.data.len()).rev().zip(self.data.iter()) {","highlight_start":1,"highlight_end":91},{"text":"                let z = bv.rank0(range.end) - bv.rank0(range.start);","highlight_start":1,"highlight_end":69},{"text":"                if z > k {","highlight_start":1,"highlight_end":27},{"text":"                    // 求めるものの上からlbit目は0です。","highlight_start":1,"highlight_end":43},{"text":"                    range.start = bv.rank0(range.start);","highlight_start":1,"highlight_end":57},{"text":"                    range.end = bv.rank0(range.end);","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    k -= z;","highlight_start":1,"highlight_end":28},{"text":"                    ret |= 1 << l;","highlight_start":1,"highlight_end":35},{"text":"                    range.start = zero + bv.rank1(range.start);","highlight_start":1,"highlight_end":64},{"text":"                    range.end = zero + bv.rank1(range.end);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ret","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fn _count(&self, mut range: Range<usize>, a: u64) -> usize {","highlight_start":1,"highlight_end":69},{"text":"            //! Return: the number of value∈[0, a) in range","highlight_start":1,"highlight_end":60},{"text":"            let mut ret = 0;","highlight_start":1,"highlight_end":29},{"text":"            for (l, &(zero, ref bv)) in (0..self.data.len()).rev().zip(self.data.iter()) {","highlight_start":1,"highlight_end":91},{"text":"                if !access(a, l) {","highlight_start":1,"highlight_end":35},{"text":"                    range.start = bv.rank0(range.start);","highlight_start":1,"highlight_end":57},{"text":"                    range.end = bv.rank0(range.end);","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    ret += bv.rank0(range.end) - bv.rank0(range.start);","highlight_start":1,"highlight_end":72},{"text":"                    // aのl bit目は1ですから、range内でl bit目が0のものはa未満です。","highlight_start":1,"highlight_end":64},{"text":"                    range.start = zero + bv.rank1(range.start);","highlight_start":1,"highlight_end":64},{"text":"                    range.end = zero + bv.rank1(range.end);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ret","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        pub fn rangefreq(&self, range: Range<usize>, val: Range<u64>) -> usize {","highlight_start":1,"highlight_end":81},{"text":"            self._count(range.clone(), val.end) - self._count(range, val.start)","highlight_start":1,"highlight_end":80},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `crate::wavelet_matrix` to refer to this module unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `wavelet_matrix` is ambiguous (name vs any other name during import resolution)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs:11:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse wavelet_matrix::WaveletMatrix;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `wavelet_matrix` could refer to a crate passed with `--extern`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `::wavelet_matrix` to refer to this crate unambiguously\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `wavelet_matrix` could also refer to the module defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs:223:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod wavelet_matrix {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    mod __pseudo_extern_prelude {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        pub(super) use crate::__bit_vector_0_1_0 as bit_vector;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m349\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m350\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `crate::wavelet_matrix` to refer to this module unambiguously\u001b[0m\n\n"}
{"message":"unused import: `std::ops::Range`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":356,"byte_end":371,"line_start":8,"line_end":8,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use std::ops::Range;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"verification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs","byte_start":352,"byte_end":372,"line_start":8,"line_end":8,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::ops::Range;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::ops::Range`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mverification/library-checker/src/bin/yosupo_range_kth_smallest_equiped.rs:8:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::ops::Range;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0659`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0659`.\u001b[0m\n"}
